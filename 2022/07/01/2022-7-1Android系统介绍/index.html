<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="&lt;p&gt;Android系统介绍&lt;/p&gt;"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>Android系统介绍 | Mijm Blog</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 6.3.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Archives</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-none-link" href="/tags/Android/" rel="tag">Android</a></div><div class="post-time">2022-07-01</div></div></div><div class="container post-header"><h1>Android系统介绍</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E7%BC%96"><span class="toc-number">1.</span> <span class="toc-text">单编</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">启动流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.</span> <span class="toc-text">镜像介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%8C%BA"><span class="toc-number">4.</span> <span class="toc-text">分区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Modem%E5%88%86%E5%8C%BA"><span class="toc-number">4.1.</span> <span class="toc-text">Modem分区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bootloader%E5%88%86%E5%8C%BA"><span class="toc-number">4.2.</span> <span class="toc-text">bootloader分区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#boot%E5%88%86%E5%8C%BA"><span class="toc-number">4.3.</span> <span class="toc-text">boot分区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#recoverty%E5%88%86%E5%8C%BA"><span class="toc-number">4.4.</span> <span class="toc-text">recoverty分区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#system%E5%88%86%E5%8C%BA"><span class="toc-number">4.5.</span> <span class="toc-text">system分区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#data%E5%88%86%E5%8C%BA"><span class="toc-number">4.6.</span> <span class="toc-text">data分区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cache%E5%88%86%E5%8C%BA"><span class="toc-number">4.7.</span> <span class="toc-text">cache分区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#misc%E5%88%86%E5%8C%BA"><span class="toc-number">4.8.</span> <span class="toc-text">misc分区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vbmeta%E5%88%86%E5%8C%BA"><span class="toc-number">4.9.</span> <span class="toc-text">vbmeta分区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dtbo%E5%88%86%E5%8C%BA"><span class="toc-number">4.10.</span> <span class="toc-text">dtbo分区</span></a></li></ol></li></ol></details></div><div class="container post-content"><p>Android系统介绍</p>
<span id="more"></span>

<h2 id="单编"><a href="#单编" class="headerlink" title="单编"></a>单编</h2><ul>
<li>make clean（清理）</li>
<li>make update-api（更新api和doc一致）</li>
<li>make systemimage（单编 system.img，make snod）</li>
<li>make bootimage（单编 boot.img，由kernel, dtb, ramdisk组成）</li>
<li>make userdataimage-nodeps（单编 userdata.img）</li>
<li>make aboot（单编 abl.elf，也是bootloader，uboot）</li>
<li>make target-files-package	编target-files</li>
</ul>
<h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><p><code>bootloader.img -&gt; boot.img -&gt; system.img</code><br><code>Android</code> 在启动的时候，会由 <code>UBOOT</code> 传入一个 <code>init</code> 参数，这个<code>init</code> 参数指定了开机的时候第一个运行的程序，默认就是 <code>init</code> 程序，这个程序在 <code>ramdisk.img</code>中。<br>可以分析一下它的代码，看看在其中到底做了一些什么样的初始化任务，它的源文件在<code>system/core/init/init.c</code> 中。<br>它会调用到 <code>init.rc</code>初始化文件，这个文件在 <code>out/target/product/generic/root</code> 下，我们在启动以后，会发现根目录是只读属性的，<br>而且 <code>sdcard</code> 的 <code>owner</code> 是<code>system</code>，就是在这个文件中做了些手脚，可以将它改过来，实现根目录的可读写。</p>
<p>通过分析这几个文件，还可以发现，<code>android</code> 启动时首先加载 <code>ramdisk.img</code> 镜像，并挂载到<code>/</code>目录下，并进行了一系列的初始化动作，<br>包括创建各种需要的目录，初始化 <code>console</code>，开启服务等。<br><code>System.img</code>是在 <code>init.rc</code>中指定一些脚本命令，通过 <code>init.c</code> 进行解析并挂载到根目录下的<code>/system</code> 目录下的。</p>
<h2 id="镜像介绍"><a href="#镜像介绍" class="headerlink" title="镜像介绍"></a>镜像介绍</h2><ol>
<li>ramdisk.img : 一个分区镜像文件，它会在<code>kernel</code> 启动的时候，以只读的方式被 <code>mount</code> ， 这个文件中只是包含了 <code>/init</code> 以及一些配置文件，这个<code>ramdisk</code> 被用来调用<code>init</code>，以及把真正的<code>root file system mount</code> 起来。</li>
<li>system.img：是包含了整个系统，<code>android</code> 的<code>framework</code>，<code>application</code> 等等，会被挂接到 “<code>/</code>” 上，包含了系统中所有的二进制文件</li>
<li>userdata.img： 将会被挂接到 <code>/data</code> 下，包含了所有应用相关的配置文件，以及用户相关的数据 。</li>
<li>boot.img：包括 <code>boot header，kernel， ramdisk</code><br><code>boot</code>镜像不是普通意义上的文件系统，而是一种特殊的<code>Android</code>定制格式，由文件头信息<code>boot header</code>，压缩的内核，<br>文件系统数据<code>ramdisk</code>以及<code>second stage loader</code>（可选）组成，它们之间非页面对齐部分用0填充</li>
<li>update.img：将所有的img文件，通过指定打包工具，制作<code>update.img</code>，批量生产中常用到此镜像文件</li>
</ol>
<h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><h3 id="Modem分区"><a href="#Modem分区" class="headerlink" title="Modem分区"></a>Modem分区</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实现手机必需的通信功能，大家通常所的刷RADIO就是刷写modem分区，在所有适配的ROM中这部分是不动，否则会造成通话不稳定</span><br></pre></td></tr></table></figure>

<h3 id="bootloader分区"><a href="#bootloader分区" class="headerlink" title="bootloader分区"></a>bootloader分区</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1.bootloader的primary bootloader部分，主要执行硬件检测，确保硬件能正常工作，然后将second bootloader拷贝到内存(RAM)开始执行</span><br><span class="line">2.Second bootloader会进行一些硬件初始化工作，获取内存大小信息等，然后根据用户的按键进入到某种启动模式。</span><br><span class="line">    比如说大家所熟知的通过电源键和其它一些按键的组合，可以进入到recovery，fastboot或者选择启动模式的启动界面等。</span><br><span class="line">3.区分</span><br><span class="line">    高通分为xbl.elf和abl.elf</span><br><span class="line">        bootable/bootloader/edk2</span><br><span class="line">    mtk分为preloader和lk，后者是一些接口，调用前者的实现</span><br><span class="line">        vendor/mediatek/proprietary/bootable/bootloader/lk</span><br><span class="line">        vendor/mediatek/proprietary/bootable/bootloader/preloader</span><br><span class="line"></span><br><span class="line">    fastboot模式：fastboot是android定义的一种简单的刷机协议，用户可以通过fastboot命令行工具来进行刷机。</span><br><span class="line">    比如说fastboot flash boot boot.img这个命令就是把boot.img的内容刷写到boot分区中。</span><br><span class="line">    一般的手机厂商不直接提供fastboot模式刷机，总是会提供自己专有的刷机工具和刷机方法。比如说三星的Odin，摩托的RSD，华为的粉屏等等。</span><br><span class="line">    但是其本质实际上是相同的，都是将软件直接flash到各个分区中。这种通常称为线刷，是比较原始的方法。当手机处于开不了机的情况下，可以使用此厂家提供的工具进行刷入</span><br></pre></td></tr></table></figure>

<h3 id="boot分区"><a href="#boot分区" class="headerlink" title="boot分区"></a>boot分区</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当我们只是按下电源键开机时，会进入正常启动模式。</span><br><span class="line">Secondarystagebootloader会从boot分区开始启动。Boot分区的格式是固定的，首先是一个头部，然后是Linux内核，最后是用作根文件系统的ramdisk。</span><br><span class="line">当Linux内核启动完毕后，就开始执行根文件系统中的init程序，</span><br><span class="line">init程序会读取启动脚本文件(init.rc和init.xxxx.rc),执行脚本中指定的动作和命令，脚本中的一部分是运行system分区的程序</span><br></pre></td></tr></table></figure>

<h3 id="recoverty分区"><a href="#recoverty分区" class="headerlink" title="recoverty分区"></a>recoverty分区</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">recovery模式：recovery是android定义的一个标准刷机协议。</span><br><span class="line">当进入recovery模式时，second bootloader从recovery分区开始启动，recovery分区实际上是一个简单的Linux系统，</span><br><span class="line">当内核启动完毕后，开始执行第一个程序init(init程序是Linux系统所有程序的老祖宗)。</span><br><span class="line">init会启动一个叫做recovery的程序（recovery模式的名称也由此而来）。</span><br><span class="line">通过recovery程序，用户可以执行清除数据，安装刷机包等操作。</span><br><span class="line">一般的手机厂商都提供一个简单的recovery刷机，多只能进行upate的操作。不能进行卡刷；如果想要自已卡刷，则需要事先刷入第三方的Recovery，然后选择刷机包。</span><br></pre></td></tr></table></figure>

<h3 id="system分区"><a href="#system分区" class="headerlink" title="system分区"></a>system分区</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">除linux Kernel部分位于boot分区外，在其上的Library、runtime、framework、core application都是处于system分区</span><br><span class="line">1、/system/priv-app</span><br><span class="line">    特权App，比system_app权限还要高，其不仅System_app标识是true，同时还置了Priv-app标识。</span><br><span class="line">2、/system/app</span><br><span class="line">    核心应用程序档(*.apk: Android应用程序包)，都是放在这。像是Phone、Alarm Clock, Browser, Contacts 等等。</span><br><span class="line">3、/system/framework</span><br><span class="line">    这里放 Android 系统的核心程序库，就是上图中application framework部分的库。像是core.jar, framework-res.apk, framework.jar等等。</span><br><span class="line">4、system/lib</span><br><span class="line">    存放Library部分的库，存放的是所有动态链接库(.so文件)，这些.SO是JNI层，Dalvik虚拟机，本地库，HAL层所需要的，</span><br><span class="line">    因为系统应用/system/app下的apk是不会解压的SO到程序的目录下，所以其相应用的SO，都应放在/system/lib 下面。</span><br><span class="line">    当一个系统apk的SO加载时，会从此目录下寻找对应用的SO文件；</span><br><span class="line">5、/system/media/audio/(notification, alarms, ringtones, ui)</span><br><span class="line">    这里放系统的声音档，像是闹铃声，来电铃声等等。这些声音档，多是 ogg 格式。</span><br><span class="line">6、/system/bin</span><br><span class="line">    存放的是一些可执行文件，基本上是由C/C++编写的。其中有一个重要的命令叫app_process。一般大家称之为Zygote。</span><br><span class="line">    （Zygote是卵的意思，所有的Android进程都是由它生出来的)。Zygote首先会加载dalvik虚拟机，然后产生一个叫做system_server的进程。</span><br><span class="line">    system_server顾名思义被称作Android的系统服务程序，它主要管理整个android系统。</span><br><span class="line">    system_server启动完成后开始寻找一个叫做启动器的程序，找到之后由zygote开始启动执行启动器，这就是我们常见到的桌面程序。</span><br><span class="line">7、system/xbin</span><br><span class="line">    存放的是一些扩展的可执行文件，既该目录可以为空。大家常用的busybox就放在该目录下。Busybox所建立的各种符号链接命令都是放在该目录。</span><br><span class="line">8、system/build.prop</span><br><span class="line">    build.prop和上节说得根文件系统中的default.prop文件格式一样，都称为属性配置文件。它们都定义了一些属性值，代码可以读取或者修改这些属性值。属性值有一些命名规范：</span><br><span class="line">    　　ro开头的表示只读属性，即这些属性的值代码是无法修改的。</span><br><span class="line">    　　persist开头的表示这些属性值会保存在文件中，这样重新启动之后这些值还保留。</span><br><span class="line">    　　其它的属性一般以所属的类别开头，这些属性是可读可写的，但是对它们的修改重启之后不会保留。</span><br><span class="line">9、system/etc</span><br><span class="line">    目录存放一些配置文件，和属性配置文件不一样，这下面的配置文件可能稍微没那么的有规律。</span><br><span class="line">    一般来说，一些脚本程序，还有大家所熟悉GPS配置文件(gps.conf)和APN配置文件(apns-conf.xml)放在这个目录。</span><br><span class="line">    像HTC将相机特效所使用的一些文件也放在这个目录下。</span><br></pre></td></tr></table></figure>

<h3 id="data分区"><a href="#data分区" class="headerlink" title="data分区"></a>data分区</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">当我们开机进入桌面程序后，一般来说我们都会下载安装一些APP，这些APP都安装在data/app目录下。所有的Android程序生成的数据基本上都保存在data/data目录下。</span><br><span class="line">wipedata实质上就是格式化data分区，这样我们安装的所有APP和程序数据就都丢失了。</span><br><span class="line">1、/data/app</span><br><span class="line">    放的是使用者自己安装的应用程式执行档(*.apk)。</span><br><span class="line">2、/data/data/</span><br><span class="line">    当你在程式中用Context.openFileOutput() 所建立的档案，都放在这个目录下的files 子目录内。而用Context.getSharedPreferences() 所建立的preferences 档(*.xml) ，则是放在shared_pref 这个子目录中。</span><br><span class="line">3、/data/anr/traces.txt</span><br><span class="line">    当你的应用程式发生ANR (Application is Not Responding) 错误时，Android 会自动将问题点的code stack list 写在这个档案内，你直接用cat 命令就可以看他的内容。</span><br><span class="line">4、/data/system/dropbox/***.txt</span><br><span class="line">    主要是系统内apk发生crash时写的日志文件，主要有system_app_crash、data_app_crash等日志。</span><br><span class="line">5、/data/location/gps</span><br><span class="line">    是给GPS location provider 用的。其中的 properties 档案的内容如下：</span><br><span class="line">6、/data/system/location/location.gps</span><br><span class="line">    一般文字档。主要是记录最后的经纬度座标。 LocationManager.getLastKnownLocation() 就在来这抓值的。</span><br><span class="line">7、/data/property/persist.sys.timezone</span><br><span class="line">    这个档案也是个一般文字档。主要是记录目前系统所使用的时区。在我的模拟器上，他记录着Asia/Taipei 这个字串。</span><br></pre></td></tr></table></figure>

<h3 id="cache分区"><a href="#cache分区" class="headerlink" title="cache分区"></a>cache分区</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">此分区是安卓系统缓存区，他保存系统最常访问的数据和应用程序。</span><br><span class="line">擦除这个分区，不会影响个人数据，只是删除了这个分区中已经保存的缓存内容，缓存内容会在后续手机使用过程中重新自动生成。</span><br></pre></td></tr></table></figure>

<h3 id="misc分区"><a href="#misc分区" class="headerlink" title="misc分区"></a>misc分区</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">misc分区中有Bootloader Control Block（BCB），主要是用于存放Recovery引导信息。</span><br></pre></td></tr></table></figure>

<h3 id="vbmeta分区"><a href="#vbmeta分区" class="headerlink" title="vbmeta分区"></a>vbmeta分区</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">验证启动（Verified Boot）是Android一个重要的安全功能，主要是为了访问启动镜像被篡改，提高系统的抗攻击能力，简单描述做法就是在启动过程中增加一条校验链，即 ROM code 校验 BootLoader，确保 BootLoader 的合法性和完整性，BootLoader 则需要校验 boot image，确保 Kernel 启动所需 image 的合法性和完整性，而 Kernel 则负责校验 System 分区和 vendor 分区。</span><br><span class="line">由于 ROM code 和 BootLoader 通常都是由设备厂商 OEM 提供，而各家实际做法和研发能力不尽相同，为了让设备厂商更方便的引入 Verified boot 功能，Google 在 Android O上推出了一个统一的验证启动框架 Android verified boot 2.0，好处是既保证了基于该框架开发的verified boot 功能能够满足 CDD 要求，也保留了各家 OEM 定制启动校验流程的弹性。</span><br><span class="line">由于 ROM code 校验 BootLoader 的功能通常与 IC的设计相关，所以 AVB 2.0 关注的重点在 BootLoader 之后的校验流程。BootLoader 之后系统启动所涉及的关键镜像通常包括 boot.img，system.img，Android O 的 treble Project 还引入了 dtbo 和 vendor.img。这些 image 挨个校验可以说费时费力，而 AVB 2.0 的做法事实上十分简单，引入一个新的分区：vbmeta.img（verified boot metadata），然后把所有需要校验的内容在编译时就计算好打包到这个分区，那么启动过程中 BootLoader 只需要校验 vbmeta.img，就能确认 vbmeta 内的数据是否可信。再用 vbmeta 中的数据去比对 bootimg，dtbo，system,img，vendor.img 即可。至于 OEM 是还需要放什么其他东西到 vbmeta 中，则可以由 OEM 自由定制，可以说保留了很好的客制化空间。</span><br><span class="line">除了最基本的验证启动之外，AVB 2.0 还提供防止回滚的功能和对AB分区备份的支持，具体的可以看README文档（安卓源码external/avb/README.md）。</span><br><span class="line">生成过程：</span><br><span class="line">    vbmeta.img 这个镜像不是编译生成的，它是依赖avbtool 工具生成，这个其实是一个python脚本，详细原理可以参阅external/avb/avbtool 源码，这里我们只整理Android源码下的生成流程，用最原始的方法追踪生成流程（事实证明是最直接、最有效的 ），安卓代码编译之后，在编译log只能看到一句log：</span><br></pre></td></tr></table></figure>

<h3 id="dtbo分区"><a href="#dtbo分区" class="headerlink" title="dtbo分区"></a>dtbo分区</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dt或者dto镜像在这里Google把它笼统地称作dtbo镜像，他们的格式是一样的，都是把多个dtc编译出来的dtb二进制或者dto二进制打包到一个image</span><br><span class="line">每个硬件设备对应一个dtb和dto，把多个dtb或者dto按照图示的格式打包成对应的dt.img和dto.img，这样软件可以做到共镜像，方便了厂商对产品的维护工作</span><br></pre></td></tr></table></figure>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/lato-font/3.0.0/css/lato-font.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcdn.net/ajax/libs/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcdn.net/ajax/libs/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>