---
uuid: 105bdad4-bcd3-11ed-abae-3fce2bc8128b
title: Java基础
date: 2015-9-1
tags:
  - Java
categories:
  - Java
abbrlink: f7ede91d
---

Java基础

<!--more-->

```
一、基础语法
1. JAVA简介
1.1 java体系结构：j2se,j2ee,j2me
1.2 java特点：平台无关（虚拟机）,垃圾回收(使得java更加稳定)
1.3 JDK、JRE与JVM
JDK:java开发环境 JRE：java运行环境
JVM：java虚拟机
1.4 java程序的开发步骤：.java   编译（javac）成  .class 运行(java)  .class文件


2. 基本数据类型（标、关、常、变、基）
2.1 标志符：自己可以取名字的地方称为标志符
* 标志符的规则：1，只能是字母，数字，下划线，$;不能以数字开头;严格区分大小写；不能使用关键字作为标志符
* 规则：（字下美人 数 骆驼）

2.2 关键字：关键字都是小写
 
2.3 常量：如123，"hello"
* 一般使用static final定义常量，如public static final int SLOW_SPEED=1;
 
2.4 变量：变量的本质是内存中的一小块区域，用这个区域保存数据
* 变量申明：类型  变量名字
* 变量必须先声明，再赋值，再使用
* 注意区分基本数据类型的变量与引用数据类型的变量
* 变量的作用域，局部变量与成员变量：变量在哪个大括号里定义，就在哪里有效，出了大括号无效
 
2.5 基本数据类型：java数据类型分为两大类：基本数据类型，引用数据类型
* 基本数据类型分为4类8中：boolean,char,byte,short,int,long,float,double
* boolean类型只有true，false
* char是Unicode编码
* float,double是有精度的（不是绝对精确的）
 
2.5.1 基本数据类型之间的转换
* 123默认是int型，12.3默认是double型（其他要在后面追加l、f）
* <=int的时候，默认转换为int；否则以式子中最大的类型计算
* 小容量可以隐式转换为大容量；大容量要强转为小容量
* byte,short,char——>int——>long——>float——>double
* boolean与其他类型不兼容


3. 运算符与流程控制
3.1 运算符：算术、关系、逻辑、赋值、位运算符
算数：+、 -、 *、 /、 %、 ++、 --（自加自减++,--，注意顺序）
关系：>、 <、 ==、 >=、 <=、 !=
逻辑：&&、||、!
赋值：=

* 关系运算符的结果是boolean类型
* 逻辑运算符，短路逻辑的结果也是boolean类型
* 三元运算符 (逻辑表达式) ? 表达式一 :表达式二

3.1.1 ++、--顺序
* 如果运算符在前，那么在本条语句运行之前操作
* 如果运算符在后，那么在本条语句运行之后操作

3.1.2 &与&&、|与||区别
* &有两种解释：一是按位与，另一个就是且
* &&只有且，并带有短路功能（如果前面某个条件被否定了，那么将不会执行后面的条件）

3.2 流程控制语句：顺序（continue,break,return）、分支（if,switch）、循环(for,while,do while)


3.2.1 break,continue,return
* break，continue一般用在循环中，也可以用在switch中
* break：跳出最近的整个循环（结束循环）
* continue：跳过最近整个循环的本次循环，进入下一次循环
* return：结束整个方法，或带参返回方法体


3.2.2 switch的规则：
* switch只能探测:byte,short,char,int 类型的值（case后面也只能是这4种）
* switch中小心case的穿透(代码会一直运行，直到遇到break停止，建议每个case写一个break)
* default：如果没有找到匹配的case，则执行default


3.2.3 for，while，do while搞清楚代码的执行流程


二、面向对象
1. 面向对象基本语法
1.1 定义一个类
* 使用class关键字定义类，注意类名大写
* 成员属性：成员属性不赋值会有默认值
* 成员方法
* 构造方法：没有任何返回值，名字与类名一样，构造方法的本意是用来初始化对象（初始化对象的属性值）


1.2 实例化对象：Student s = new Student();
* 使用new + 构造方法  实例化对象
* new 在堆中开辟了对象的空间，并且给属性赋上默认值
* 接下来调用构造方法，执行构造方法中的代码
* 最后返回对象的引用


1.3  区分基本数据类型与引用数据类型
* 基本数据类型在内存中只有一块空间：里面存着值（栈）
* 引用类型的变量在内存中有两块区域，一块是引用本身，另一块是引用所指向的对象（堆栈）


1.4  如何操作对象：使用.操作符
* 使用对象名.属性操作对象的属性（如:stu.age = 18;）
* 使用对象名.方法调用对象的方法(如：stu.study());
* this：每个对象都有this，this是指向本身的引用，代表本身
* super：super代表父类的引用

1.5 类与对象的初始化过程：
* 静态属性先初始化，而且仅仅初始化一次
* 首先给静态属性进行声明，并赋默认值，然后代码从上往下执行静态代码块或静态赋值
* 每创建一个对象，就先实例化成员属性：首先给成员属性声明，赋默认值，然后.执行赋值语句
* 成员属性初始化后再调用构造方法


1.6 垃圾回收机制
* java虚拟使用垃圾回收机制进行垃圾回收
* 垃圾回收本身是一个线程(当内存不够用的时候，一般会进行垃圾回收)
* 垃圾回收不能通过程序来调用，仅仅能够通过System.gc()建议虚拟机进行垃圾回收
* 当进行垃圾回收时，会调用对象的finalize方法

1.7 单例模式：一个类仅仅能有一个实例(23个设计模式的一种)
* 构造方法必须为私有的
* 提供静态的方法来获得对象
* 提供静态的属性，该属性是该类的一个对象


2. 访问控制，方法定义与调用，重载，方法重写
2.1 package包的使用
* 使用 package 定义包：package只能放在代码的第一行
* import：导包，可以到入包下所有 import java.io.*;可以导入具体的一个类 import java.io.Reader;
* 包的作用:1,分类；2，隐藏（封装的作用），3,便于管理
* java本身提供了一些包：java.lang(核心类，此包如需要引入),java.util(集合框架以及其他常用类)，java.io(输入输出),java.awt,javax.swing(图形)


2.2 四个访问级别，从大到小：public ，protected，friendly，private
public  protected  friendly  private
其他包 Y
N N  N
子孙类 Y
Y N  N
本包 Y
Y Y  N
本类 Y
Y Y  Y

* 注意访问级别是针对类来讲的，不是针对对象！！！！！！！
* 注意类的访问修饰符只能使用public 或 默认
* 学了访问控制后：类的属性都写private，通过set/get方法对属性进行赋值，取值

3. 面向对象的特性
3.1 封装：封装是把过程和数据包围起来，对数据的访问只能通过已定义的接口
* 封装的目的就是要实现软件内部的“高内聚、低耦合”，防止程序相互依赖而产生变动的影响

3.2 继承：子类自动共享父类的数据和方法
* 使用extends关键字表示继承
* 子类继承父类的所有属性
* 子类继承父类除private（非同包的时候也除默认的方法）外的所有方法
* 子类对象拥有super引用，表示父类的引用,可以使用super明确的调用父类的方法或属性

* 子类自动共享父类的数据和方法的机制，提高了代码的可重用性和可扩展性

3.2.1 重载与重写
3.2.1.1 重载：一个类当中，有方法名相同，参数不同的方法，称为重载
* 不能只改返回值：不能根据方法的返回进行重载


3.2.1.2 重写：在继承当中，子类将父类的方法重新写了一遍：重写的方法与被重写的方法拥有相同的方法签名（返回值类型，方法名，参数列数）
* .重写的方法能够改变被重写的方法的访问级别,注意只能是相等或者扩大
* .重写的方法不能抛出比被重写方法更多的异常，注意只能缩小异常的范围
* .如果被重写的方法是具体的，重写之后不能改为abstract

3.2.2 构造方法的继承（基类即父类）
* 子类的构造过程必须调用其基类的构造方法
* 子类可以在自己的构造过程中使用super(arg[] list）来调用基类的构造方法
* 如果调用super，必须写在子类构造方法的第一行
* 可以使用this(arg[] list)调用本类的另外的构造方法
* 如果子类的构造方法中没有显示的调用基类的构造方法，系统默认调用基类无参数的构造方法
* 如果子类构造方法中既没有显式的调用基类构造方法，基类中又没有无参数的构造方法，编译出错

3.2.3 对象的转型
* 一个基类的引用类型变量可以指向其子类的对象
* 一个基类的引用不可以访问其子类对象新增的成员
* 可以使用  instanceof 关键字来判断一个引用类型变量所指向的对象是否是制定的类型
* 子类的对象可以当作基类来使用称作向上转型，反之称为向下转型
* 子类可以当成父类来使用，无需显示转换
* 父类引用转换为子类引用要进行强制转换
* 注意：不兼容的类型之间不能进行相互转换（只有具有直接或间接父子关系的类才是兼容的类型），否则编译时会报错
* 注意：兼容类型之间的转换要看对象的实际类型，因此向下转化时最好先用instanceof来判断是否是某个类型，再转换，以免报报错

3.3 多态：同一消息可以根据发送对象的不同而采用多种不同的行为方式
* 实现多态的技术称为：动态绑定，是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用子类相应的方法
* 多态成立的条件：1.要有继承。2.要有重写。3.父类的引用指向子类的对象。
* 多态的作用：消除类型之间的耦合关系

3.4 抽象类：用abstract修饰的类称为抽象类（抽象就是自己不实现，让具体的子类去实现）
* 抽象方法不能有方法体
* 如果是具体子类，必须重写父类抽象方法
如果不是具体子类（抽象类），则可以不重写
* 抽象类中可以没有抽象方法，但是有抽象方法的一定是抽象类

* 完全抽象类一般用接口代替


3.5 接口：interface（继承一个类，实现多个接口）
* 接口中属性只能为public static final类型（可省略）
* 接口中方法只能为public abstract类型（可省略）
* 接口也可以继承接口（不是实现），可以重写父接口的方法，等具体子类去实现

* 接口取代完全抽象类


3.6 static
* 因为是属于类，不属于对象，又叫做类变量或类方法
* 在类开始被初始化的时候就执行
* 对于该类的所有对象来说，static成员变量和方法只有一份

* 静态可以通过类直接被访问
* 在类中，静态方法中不能直接访问非静态成员
* 在类中，静态成员方法没有this引用


3.7 final关键字:final表示最终的意思
* final的变量的值不能够被改变
* final的成员变量
* final的局部变量(形参)
* final的方法不能够被重写
* final的类不能够被继承




4. 异常处理
java的异常处理机制
异常的关键字Exception
try,catch,finally,throw,throws关键字


4.1 什么是异常，为什么要引入异常
* java程序运行时出错，java就抛出异常,程序立即终止（也可以说程序崩溃）
* java将错误信息封装在异常对象里抛出
* 学会查看异常的信息：异常的名字，异常的信息，程序抛异常的位置
* java引入异常处理机制，是防止程序出错崩溃


4.2 java的异常的分类
* java的抛出的错误用异常类来表示,java拥有一个异常体系（有许多异常类，并且相互之间具有关系）
* java里面的所有异常都是Throwable的子类
* java虚拟机的异常是Error的子类，一般不需进行处理(因为没法进行处理)
* 除Error之外还有Exception，Exception分为两类：RuntimeException(运行时异常)，被检查异常（除了RuntimeException都是被检查异常）
* RuntimeException(运行时异常，可以不捕获或声明抛出，编译不会报错,一般是控制不当造成的)，可检查异常（必须捕获或声明抛出，这类异常通常需要检测并处理，一般使用资源时造成的）
* 几个常见的异常：NullPointerException(空指针),IndexOutOfBoundsException(索引越界),SQLException(数据库异常),IOException(文件异常)


4.3 异常的处理方式
* 使用try,catch,finally进行处理
* throws在方法后抛出异常，交给调用此方法的处理（可以连续抛）
* throw在方法体中抛出异常


4.4 try,catch,finally中程序的运行过程
* 尝试执行try里面的语句
* 一次运行当中最多执行一个catch块，如果没有抛出异常，catch块不执行
* finally总会执行，不管有没有抛出异常
* 如果try块里面有return语句，会先运行finally内容


4.5 区分RuntimeException与被检查异常
* RuntimeException不需要捕获或声明抛出（但是如果你捕获或声明抛出也不会有错）
* 被检查异常必须要捕获或者声明抛出


5. 数组
数组是引用类型，有长度length的属性


声明，创建，赋值
* 数组声明时要指定数组元素的类型，数组的维度，不需要指定数组的长度，如：int[] a;(a是引用)
* 数组的创建必须new关键字，并且必须给出数组的长度;new int[5]
* 如果数组的类型是引用类型的数组，数组里面保存的是引用，而不是对象本身
new int[] { 1,3,4,5}
{1,4,5,6}


数组的常用操作类
Arrays提供了数组的常用操作的方法（这些方法都是静态的）
* 排序：sort
* 返回数组的字符串表示：ToString


二维数组
* 二维数组的内存分析
* 数组的拷贝使用System.arrayCopy方法

6. 多线程
1.线程的概念
* 程序里面不同的执行路径，每一个执行路径称为一个线程
* 对于单cpu来讲，某一具体的时刻，只会有一个线程在运行，但是CPU的速度非常快，表面上看起来是许多个线程并行执行


2.java中线程的创建与启动
* 两种实现线程的方式:继承Thread，实现Runnable接口
* 线程的启动：start.启动线程，运行线程的run方法，run方法运行完线程就结束(注意，start只在Thread里面有，start不同于run)
* 注意一个Thread对象，只能一次调用start方法
* Thread与Runnable的区别：1：Runnable是接口，比Thread灵活（因为java只能单继承，可以同时实现许多接口）;2.一个Runnable对象可以启动许多个线程，线程之间共享对象（Thread不能共享对象）


3.线程的状态：new ,可运行，运行中，阻塞，死亡


4.线程的调度
* Thread.sleep,使该线程睡眠
* join：线程合并(结果类似与方法调用)
* yield:线程让出当前CPU，留给其他线程运行
* 线程优先级:setPriority设置线程优先级
* 后台线程:setDaemon,必须在线程运行前设置为后台线程.当所有的前台线程都结束了，后台线程自动结束
* 线程可以指定名字，取得当前线程的方法Thread.currentThread();


5.线程同步
* synchronized:同一时刻，只会有一个线程执行synchronized代码块


6.线程间通讯
* wait(),notify(),notifyAll是Object类中定义的方法
* wait()：使得运行该代码的线程进入对象的等待池进行等待，线程进入阻塞状态，wait的线程一直阻塞，指导其他线程调用该对象的notify方法唤醒它。
* notify()：唤醒对象等待池中的一个线程，使得被唤醒的线程进入可运行状态，如果等待池中没有线程，notify什么也不做。
* notifyAll()：唤醒对象等待池中的所有线程
* wait(),notify,notifyAll都必须放在同步代码块里面(Synchronized代码块).
* wait()的线程会释放对象的锁，而Thread.sleep的线程不会释放对象的锁


7.线程安全的类：多线程的环境下使用类或者调用类的方法不会造成同步问题的类称为线程安全的类
* JDK1.1以前，java的集合框架中有一些线程安全的类：如Vector(被ArrayList代替),HashTable(被HashMap代替)


7.内部类
1.内部类:在一个类的里面再定义一个类称为内部类
* 内部类可以访问外部类的所有的成员变量与成员方法
* 如果想在外部实例化内部类，必须使用全名:外部类.内部类

2.事件模型：
* java事件采用委托模型(授权模型),即事件源本身不处理事件，交给事件监听器来处理,因此需要把事件监听器绑定到事件源里面
* 事件源，事件，事件监听器。事件有许多种，不同的事件使用不同监听器来处理
* 事件触发后，系统自动调用事件处理方法（不需要手动调用事件处理方法），并传递事件信息作为方法参数
* 事件编写步骤：1.实现监听器接口(完成事件处理方法)；2.实例化实现监并绑定到事件源

3.事件实现方式
* 外部类
* 内部类
三、高级特性
1. 常用类
常用类:lang包不需要导入，其他的包都需要


1.Object:所有类的根类
* 对象的标识：hashCode()
* 对象的信息:toString()，默认情况下返回  对象类型@地址信息
* 对象是否一样：equals,默认情况下根据地址比较相等。==比较的是对象的地址，而equals在语义上提供相等的含义
* 重写equals与toString方法，参照Money类

2.String:不可变字符串，类，继承Object
* String重写toString，返回字符串的类容。重写了equals根据字符串的内容进行比较
* 字符串常量"1234"与new String("1234")。常量只有一个，new String（）每new一次就一个新的对像\
* 字符串的不变性,字符串一旦创建，内容不能改变
* 字符串的常用操作
* 字符串的长度：length
* 搜索一个字符串:indexOf()
* 字符串的字串:substring(3，8)
* 取得指定位置的字符:charAt(8);
* 判断字符串以什么开头(结尾):startsWith(),endWith()
* 改变字符串的大小写,toUpperCase(),toLowerCase()
* 去掉字符串两边的空格：trim()
* 替换字符串里面的某些内容:replace("")
* 分割字符串：
StringBuffer:字符串缓冲，可变字符串，提供对字符串进行更改的方法(其他的方法基本与String类似)
* 从StringBuffer得到String
* 追加 append（"abc"）;
* 在字符串中间插入insert(3,"插入的字符串')
* 删除字符串 delete(3,6);//不包括6

包装类：提供与字符串之间的转换。Integer是int类型的包装类






Math类：提供数学上的常用操作，注意：里面的方法都是静态的


Random：随即类，产生随机数，另外Math.random()也能产生0～1之间的随机数


日期：Date,SimpleDateFormat(日期格式化) ,日历Calendar 


获得控制台输入：
* Scanner sc = new Scanner(System.in);
* String str = sc.next();


2. 集合框架
集合框架:概念上分为：Set(数学集合)，List（列表），Map（字典）


1.Collection接口，Iterator接口
* Set,List继承Collection，采用Iterator进行迭代(参考testCollection)


2.Set:元素不能重复，没有顺序
* HashSet:根据hashCode判断对象是否重复(重写equals和hashCode)
* TreeSet:里面的元素按顺序排列（元素必须实现Comparable接口）


2.List：元素能够重复，有顺序即索引位置，在Collection的基础上提供了按照索引位置进行操作的方法
* ArrayList:内部使用数组实现list
* LinkedList：在List的基础上提供了对首，尾元素进行操作的方法:入getLast（），addFirst(Object o)
* 数组，AarryList，LinkeList有区别
3.map：键值对的集合，key不能重复，value可以重复
* 两次put同一键，后面一个会覆盖前面一个
* 遍历map的方式：先取得keySet，或者entrySet，再用Set的方式(Iterator)进行遍历

4.泛型：List<Integer> list = new ArrayList<Integer>
* 存入的元素只能是指定类型,如：<Integer>
* 取出来不需要强制转换,自动是指定类型，如：<Integer>




5.List的常用操作类Collections，不同于Collection，提供对List的排序，随机排列，倒序的方法
* Arrays使用在数组里面，提供对数组的常用操作，跟Collections有相似之处，


6.Comparable接口
* compareTo()
* 如果需要进行排序(Collections.sort())，或者放到排序的集合里面(TreeSet,TreeMap),必须实现Comparable接口

注：Set：（集合：不重复，无序）
HashSet：
TreeSet：（由大到小）
List：（列表：重复，有序）
ArrayList：（有下标，查比较快）
LinkedList：（无下标，增删改较快）
Map：（字典）
HashMap：（存放键值对）
TreeMap：（由大到小）


3. JDBC
JDBC:java操作数据库的一组API(注意模仿)

1.加载驱动
Class.forName("com.mysql.jdbc.Driver");


2.连接数据库
Connection connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/test?useUnicode=true&characterEncoding=utf-8","root","1234");


3.PrepareStatement预编译语句
PrepareStatement pst = connection.prepareStatement("select * from user where id = ?");
pst.setObject(1,param);

4.执行
ResultSet rs = pst.executeQuery();//查询
int result = pst.executeUpdate();//增删改


/*
while(rs.next()){
int id = rs.getInt("id");
String name = rs.getString("name");
String pwd = rs.getString("pwd");
}
*/

5.关闭数据，从下到上
rs.close();
pst.close();
connection.close();

6.使用事务
* 设置手动提交：设置connection.setAutoCommit(false);
* 在最后手动提交：connection.commit();
* 在catch中捕获异常，使用connection.rollBack();



4. 图形-布局，常用Swing组件
图形用户界面（Swing常用组件，布局管理器，事件模型，绘图）


1.AWT与Swing
* AWT是重量级的组件,Swing是轻量级别组件,Swing是从awt的基础上发展过来的
* swing依然使用awt里面的布局与事件模型
* 组件：每一个界面元素都称为一个组件，如按钮，文本框
* 容器的概念：可以容纳其他元素的组件，通过add()往容器里面加入组件，每一个容器都可以设置自己的布局管理器(Layout)


2.常用组件
* 框架：JFrame（有一个默认的内容面板）,一般来将，所有的其他组件都放在JFrame的默认面板上。通过JFrame.getContentPane()获得默认内容面板
* 面板：JPanel
* 标签：JLabel
* 文本输入框：JTextField
* 文本域(多行文本):JTextArea
* 单选按钮:JRadioButton
* 复选框：JCheckBox
* 下拉列表：JComboBox
* 按钮:JButton

3。布局管理器（流布局Flowlayout,边框布局 BorderLayout,网格布局GridLayout）
* 使用setLayout(new FlowLayout())方法设置容器的布局管理器
* Flowlayout:当拖动界面的时候，元素的大小不会改变，仅改变元素的位置，可以指定居中对齐，左对齐，右对齐等对齐方式
* BorderLayout：将界面分为东西南北中五部分.:元素大小会发生改变，但是相对位置不变。除中间区域（自动填充）之外，区域里面不加组件，默认大小为0.如果往区域里加入多个组件，只显示最后添加的组件。
* GridLayout:每个网格的大小相等，位置不发生改变，大小随容器大小变化而变化




5. 图形-事件处理，绘图
图形用户界面



四、总结
1.结构
常用类、集合框架、JDBC、swing
↑
↑
封装、继承、多态、抽象
interface、static、final
异常、数组、线程
↑
↑
基本数据类型（引用数据类型）（标关常变）
运算符
流程控制

2.面向对象
封装：（高内聚、低耦合）封装就是保证软件内部具有优良的模块性基础，封装的目的就是要实现软件内部的“高内聚、低耦合”，防止程序相互依赖而产生的变动影响。
继承：（重用性、扩展性）继承是子类自动共享父类的数据和方法的机制，提高了代码的可重用性和可扩展性。
多态：（灵活性、扩展性）不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，多态性增强了程序的灵活性和扩展性。

























// ========================================== 内存机制 ==========================================
	1)Java把内存划分成两种:一种是栈内存，一种是堆内存
		栈内存用来存放一些基本类型的变量和对象的引用变量。
		堆内存用来存放由new创建的对象和数组。     


	2)具体的说:
		堆的优势:可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。
		缺点:因为要在运行时动态分配内存，存取速度较慢。 
		栈的优势:数据可以共享，存取速度比堆要快，仅次于寄存器。
		缺点:存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。

		栈中主要存放一些基本类型的变量(byte，short，int，long，float，double，boolean，char)和对象句柄。 
		栈的数据共享: 
		int a = 3;
		int b = 3;
		先创建一个变量为a的引用，再存3，再创建变量为b的引用，然后查找栈中是否有3这个值，直接将b指向3。

	3)String是一个特殊的包装类数据:
		String str = new String("abc"); 
		String str = "abc"; 
		两种的形式来创建，第一种是用new()来新建对象的，它会在存放于堆中。每调用一次就会创建一个新的对象。 
		而第二种是先在栈中创建一个对String类的对象引用变量str，然后查找栈中常量池有没有存放"abc"，如果没有，则将"abc"存放进栈，并令str指向”abc”，如果已经有”abc” 则直接令str指向“abc”。 

		equals()和==:
		equals():比较对象里面的数值是否相等
		==:比较两个引用指向的地址是否相同(堆内存的首地址)

		String str = new String("asd");
		创建了1个或2个String Object
		如果常量池(constant pool)没有"asd"，则创建了2个
		如果常量池(constant pool)有"asd"，则只创建了1个
		当然这里的str本身只是一个引用，放在栈里，用来指向堆中创建出来的对象
		String str="aaa"; 创建了0个或1个String Object
		String str="aaa"+"bbb"+"ccc";
		创建了0个或1个String Object


	4)内存分配策略:
		按照编译原理的观点，程序运行时的内存分配有三种策略，分别是静态的，栈式的，和堆式的:

		静态存储分配是指在编译时就能确定每个数据目标在运行时刻的存储空间需求，因而在编译时就可以给他们分配固定的内存空间.这种分配策略要求程序代码中不允许有可变数据结构(比如可变数组)的存在，也不允许有嵌套或者递归的结构出现，因为它们都会导致编译程序无法计算准确的存储空间需求。
		堆式存储分配也可称为动态存储分配，和静态存储分配相反，在堆式存储方案中，程序对数据区的需求在编译时是完全未知的，只有到运行的时候才能够知道，但是规定在运行中进入一个程序模块时，必须知道该程序模块所需的数据区大小才能够为其分配内存。和我们在数据结构所熟知的栈一样，堆式存储分配按照先进后出的原则进行分配。 
		栈式存储分配要求在编译时能知道所有变量的存储要求，栈式存储分配要求在过程的入口处必须知道所有的存储要求。


// ========================================== String、StringBuffer和StringBuilder的区别 ==========================================
	(1)三者在执行速度方面的比较：
		StringBuilder>StringBuffer>String

　　(2)区别：
		String：字符串常量(不可改变)(线程安全)
	　　 StringBuffer：字符串变量(可改变)(线程非安全)
	　　 StringBuilder：字符串变量(可改变)(线程非安全)

　　(3)对于三者使用的总结：
		1.如果要操作少量的数据用 = String
		2.多线程操作字符串缓冲区下操作大量数据 = StringBuffer
		3.单线程操作字符串缓冲区下操作大量数据 = StringBuilder


// ========================================== String类的常用方法 ==========================================
	// 常用
	length();  返回字符串的长度
	valueOf();  将参数以字符串类型返回
	equals();  比较内容是否相同

	// 截字符串
	substring();  截取从a开始到b之前的字符串
	indexOf();  返回字符或字符串第一次出现的位置(第一个字母为准)

	// 替换字符串
	contains();  是否包含某字符串
	replace();  替换字符串中字符或字符串

	// 不常用
	toCharArray();
	将字符串转换为数组
	trim();  去掉字符串的前端和后端空格


// ========================================== List类常用方法 ==========================================
size();  得到List的数量
get();  得到某个下标的对象
contains();  是否包含某一项

add();  增加一项
addAll();  增加一个集合
remove();  移除一条数据
clear();  清除所有数据
	
Collections.sort();		list排序
Collections.reverse();	list倒置


// ========================================== 反射 ==========================================
	1)jdk提供反射机制的类：
		java.lang.Class;                
		java.lang.reflect.Constructor;
		java.lang.reflect.Field;        
		java.lang.reflect.Method;
		java.lang.reflect.Modifier;

	2)反射获取类的三种方法：
		//第一种  
		Class cla = Employee.class;
		//第二种  
		Employeee = new Employee();
		Class cla = e.getClass();
		//第三种  
		Class cla = Class.forName("Employee");
	
	3)常用方法：
		Field[] fields = cla.getDeclaredFields();
		//获取所有的属性
		Method[] methods = cla.getDeclaredMethods();
		//获取所有的方法
		Constructor[] constructors = cla.getDeclaredConstructors();
		//获取所有的构造方法
	
		Modifier.toString(cla.getModifiers())
		//获取访问权限
		cla.getSimpleName()
		//获取名字
	
		method.getReturnType()
		//获取返回类型
	
	
// ========================================== 构造方法 ==========================================
	如果只写了有参构造方法，那么将无法调用无参构造方法
	
	
// ========================================== 初始值 ==========================================
	基本数据类型未初始化有初始值
	引用数据类型未初始化没有初始值，且为null
	
	
// ========================================== 算法设计 ==========================================
	直通
	判断
	最好用筛选算法，不用包含算法
	循环
	
	
// ========================================== 接口回调(小偷安装监听器) ==========================================
	1)定义接口
		public interface MyListener {
			void callMeNoPerson();
			void callMeHasPerson();
		}

	2)注册接口并提供set方法
		public void goOut(){
			System.out.println("\t主人出门");
			if(myListener != null){
				myListener.callMeNoPerson();
			}
		}
		public void getIn(){
			System.out.println("\t主人回家");
			if(myListener != null){
				myListener.callMeHasPerson();
			}
		}

		private MyListener myListener;
		public void setMyListener(MyListener myListener){
			this.myListener = myListener;
		}

	3)实现接口
		final House house = new House();
		house.setMyListener(new MyListener() {
			public void callMeNoPerson() {
				System.out.println("\t\t提醒你，家里没人！！！");
			}
			public void callMeHasPerson() {
				System.out.println("\t\t提醒你，家里有人！！！");
			}
		});
		
	注：接口回调实质：底层调用顶层代码

// ========================================== 文件的创建及存取 ==========================================
	1)创建文件夹
		File folder = new File(folderPath);
		if (!folder.isDirectory()) {
			folder.mkdirs();
		}
	2)创建文件
		File file = new File(filePath);
			if (!file.exists()) {
			try {
				file.createNewFile();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	3)写入文件
		FileWriter fw = new FileWriter(filePath, isAppend);
		// boolean是否追加
		BufferedWriter bw = new BufferedWriter(fw);

		bw.write(content);

		bw.close();
		fw.close();
	4)读出文件
		FileReader fr = new FileReader(filePath);
		BufferedReader br = new BufferedReader(fr);

		String str;

		while((str = br.readLine()) != null) {
		 sb.append(str+"\n");
		}

		br.close();
		fr.close();
	5)删除文件
		file.delete();
		
// ========================================== 分割字符串、正则截数据 ==========================================
	1)分割字符串
        String value = "192.168.128.33";
        String[] names = value.split("\\.");
        for (int i = 0; i < names.length; i++) {
            System.out.println(names[i]);
        }
		
	2)正则截数据
        String str = "_input_charset=\"utf-8\"&it_b_pay=\"30m\"&show_url=\"m.alipay.com\"&sign=\"IaNZM3TOiUnJf%2B5%2FxBanH3PrNEONHUedwLwuICFWAE5lbEZZg%2Bp2zeo6D7O36PzhrRya%2BzyjumDNFEuaHyc79cXngkYeyo4%2FQA6ze0iKtQswVoGEl24%2BOkL%2BF%2FvOEmkapKaG%2FMGFn8cacu4XW39TD0KznUSJo1iF0kEC8dRWQVQ%3D\"";

        Pattern p = Pattern.compile("(show_url)= ?\"(.*?)\"");
        Matcher m = p.matcher(str);
        if (m.find()) {
            // m.group(2)第一个括号内容
            System.out.println(m.group(2));
        }
		
	3)正则替换
        this.progressStr.replaceAll("(.{5})(\\d{1,3})(%)", "$1" + progress + "$3");

```