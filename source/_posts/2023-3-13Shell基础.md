---
uuid: 9320c9a0-bd7b-11ed-b917-3f894c2e238b
title: Shell基础
date: 2023-3-13
tags:
  - Linux
categories:
  - Linux
abbrlink: '4544560'
---

Shell基础

<!--more-->

## 基础语法
```
1.变量
    1.1 变量通常是大写字母、下划线连接。可以由数字、字母、下划线组成，但不能以数字开头。
    1.2 等号=用于为变量赋值，两边不能有空格
    1.3 变量存储的数据类型可以是整数值和字符串
    1.4 对变量赋值字符串时，尽量用引号括起来，使用单引号或双引号
    1.5 对变量调用，在变量名前加$
        1.5.1 $name 是 ${name} 的简化版，但某些情况下，必须使用花括号消除歧义

    1.6 变量分类（按作用）
        1.6.1 用户自定义变量
        1.6.2 环境变量：主要保存的是和系统操作环境相关的数据
        1.6.3 位置参数变量：主要是用来向脚本中传递参数的，变量名不能自定义，变量作用也是固定的
        1.6.4 预定义变量：是Bash中已经定义好的，变量名不能自定义，变量作用也是固定的，如PATH

    1.7 变量分类（按作用域）
        1.7.1 环境变量，当前shell进程及子进程都可以用到
        1.7.2 全局变量：当前shell进程可以用到（子进程不行）
        1.7.3 局部变量：local定义，当前代码块可以用到

    1.8 字符串
        VAR_STR="hello"

        echo "all : $VAR_STR"（拼接）
        ${#VAR_STR}（长度）
        ${VAR_STR:3:2}（截取，从第3个开始，取2个）
        ${VAR_STR:3}（截取，第3个开始，到最后）
        ${VAR_STR//ll/kk}（/替换第一个，//替换所有）
        array=(${Gerrit_ID//,/ })（分割字符串）


        ${FILE_PATH#*/}（删掉第一个/ 及其左边的字符串）
        ${FILE_PATH##*/}（删掉最后一个/ 及其左边的字符串）
        ${FILE_PATH%/*}（删掉最后一个 / 及其右边的字符串）
        ${FILE_PATH%%/*}（删掉第一个/ 及其右边的字符串）
        ${NAME#-}（去掉第一个-）
        ${NAME,}（首字母小写）
        ${NAME,,}（全部小写）
        ${NAME^}（首字母大写）
        ${NAME^^}（全部大写）

        echo "index : `expr index ${VAR_STR} le`"（查找l或e第一次出现的位置）

        echo ${TargetPath} | tr \\\\ /（反斜杠替换为斜杠）

        注：单引号和双引号的区别
            '' 在单引号中所有的字符包括（$ ' ` \）都将解释称普通字符
            "" 在双引号中，这些字符将被转义（$ ' ` \）

    1.9 列表
        ARRAY=(1 "haha" 2 "kkk")
        ${ARRAY[@]}（所有）
        ${#ARRAY[@]}（数量）
        ${ARRAY[0]}（第一个）

        array_name[${#array_name[@]}]=value（添加元素）

        for var in ${ARRAY[@]}; do（遍历）
          echo "var : ${var}"
        done

2.运算符
    2.1 ++、--、+、-、*、/、%、==、!=、<<（左移）、>>（右移）、&（按位与）、^（按位异或）、|（按位或）、&&（与）、||（或）、? :（三元）
    2.2 算数运算符
        2.2.1 $(($a + $b)) 或 $(expr $a + $b) 或 `expr $a + $b`，用数学加强 $(()) 更方便
        2.2.2 种类
            $(($a + $b)) 或 $(expr $a + $b)
            $(($a - $b)),$(($a * $b)),$(($a / $b)),$(($a % $b)),$(($a++)),$(($a--))

    2.3 比较运算符
        2.3.1 [ $a -eq $b ] 或 [ $a = $b ] 或 [[ $a == $b ]] 或 test $a -eq $b，用数学加强[[]]更方便，且[[]]支持通配、正则
        2.3.2 种类
            [ $a -eq $b ] 或 [[ $a == $b ]]
            [ $a -ne $b ] 或 [[ $a != $b ]]
            [ $a -gt $b ] 或 [[ $a > $b ]]
            [ $a -ge $b ] 或 [[ $a >= $b ]]
            [ $a -lt $b ] 或 [[ $a < $b ]]
            [ $a -le $b ] 或 [[ $a <= $b ]]
        2.3.3 字符串比较
            [ "$a" == "$b" ] 是否相等
            [ "$a" != "$b" ] 是否不相等
            [ -z "$a" ] 长度为零
            [ -n "$a" ] 长度不为零
        2.3.4 文件比较
            [ -e file ] 如果文件或目录存在则为真
            [ -f file ] 如果文件存在且为普通文件则为真
            [ -d file ] 如果文件存在且为目录则为真

    2.4 逻辑运算符
        2.4.1 [[ $a > 0 && $b > 0 ]] 或 [ $a -gt 0 -a $b -gt 0 ]，用数学加强[[]]更方便
        2.4.2 种类
            [ $a == 0 -a $b == 0 ] 与 [[ $a == 0 && $b == 0 ]] 与 [ $a == 0 ] && [ $b == 0 ]
            [ $a == 0 -o $b == 0 ] 或 [[ $a == 0 || $b == 0 ]] 或 [ $a == 0 ] || [ $b == 0 ]
            [ ! -e file ] 非

    注：返回值为0表示真，非零表示假
    注：通配符
        * 匹配0或多个字符
        ? 匹配任意一个字符
        [list] 匹配 list 中的任意单一字符
        [!list] 匹配 除list 中的任意单一字符
        [c1-c2] 匹配 c1-c2 中的任意单一字符 如：[0-9] [a-z]
        {string1,string2,...} 匹配 sring1 或 string2 (或更多)其一字符串


3.流程控制
    3.1 if语句
        if [ $a -gt $b ];then
            echo "$a > $b"
        elif [ $a -lt $b ];then
            echo "$a < $b"
        else
            echo "$a == $b"
        fi

    3.2 case语句
        case $a in
          1|cp)
            echo cp
            ;;
          2|mv)
            echo mv
            ;;
          *)
            echo other
        esac

    3.3 for语句
        for var in ${ARRAY[@]};do
          echo "var : ${var}"
        done

        for var in qq ww ee rr;do
          echo $var
        done

        for (( i=0; i<${#PROJECT_LIST[@]}; i++ ));do
          echo ${PROJECT_LIST[i]}
        done

    3.4 while语句
        while [ $a == 0 ];do
          echo yes
        done

        # 死循环
        while :; do
          echo yes
        done

        # 读取文件1
        while read line;do
             echo $line
        done < $FILE_NAME

        # 读取文件2
        cat $FILE_NAME | while read line;do
             echo $line
        done

        # 读取文件3（按空格为分隔符，不是按行）
        for line in `cat $FILE_NAME`;do
             echo $line
        done

        # 读取文件4（按空格为分隔符，不是按行）
        LIST=($(cat $FILE_NAME))
        for var in ${LIST[@]};do
          echo $var
        done


4.函数
    4.1 函数定义
        function main(){
          echo yes
        }

    4.2 返回值和参数
        $@ 所有参数
        $* 所有参数
        $# 参数数量
        $$ 进程id
        $? 返回值

    注：变量分为：环境变量（所有shell可用）、全局变量（当前shell可用）、局部变量（local定义，局部可用）

```

## 其他

```
当前路径
    CUR_DIR=$(cd $(dirname $0); pwd)：bash中获取当前路径
    CUR_DIR=$(cd $(dirname $BASH_SOURCE); pwd)：source中获取当前路径
    CUR_DIR=$(cd $(dirname $(readlink -f $0)); pwd)：link的原地址

当前时间
    CUR_TIME=`date "+%Y-%m-%d %H:%M:%S"`（获取当前时间）
    CUR_TIME=`date +%s`（获取当前时间戳）
    CUR_TIME=`date -d "2010-10-18 00:00:00" +%s`（时间转时间戳）
    CUR_TIME=`date '+%Y-%m-%d %H:%M:%S' -d @1648304773`（时间戳转时间）

编译前加参数
    aaa=1 ./build.sh

取随机值
    `date +%s|md5sum|cut -c 1-8`

打印
    cat << EOF
    *******
    *******
    *******
    EOF

解析参数
    #!/bin/bash

    function usage(){
    cat << EOF
    *********************************************************************************
    Usage: ./mk [-h] [-p PROJECT] [-t TYPE] [-j30]
    Example:
        short: ./mk -p sdm660_64 -t remake
        long: ./mk --project sdm660_64 --type remake
    Optional arguments:
        -h, --help            show this help message and exit.
        -p, --project         project we needed.
        -t, --type            type like new and remake.
        -j                    use cpu number to build.
    *********************************************************************************
    EOF
    }

    function parse_params(){
      ARGS=`getopt -o hp:t:j: -l help,project:,type: -n "$0" -- "$@"`
      if [ $? != 0 ] ; then echo error "$0 exited with doing nothing." >&2 ; exit 1 ; fi

      # 将规范化后的命令行参数分配至位置参数（$1,$2,...)
      eval set -- "$ARGS"

      while true; do
        case "$1" in
          -h|--help) usage; exit 0; shift; ;;
          -p|--project) export CUSTOM_PROJECT_NAME=$2; shift 2; ;;
          -t|--type) export CUSTOM_PROJECT_type=$2; shift 2; ;;
          -j) export CUSTOM_CPU_NUMBEr=$2; shift 2; ;;
          --) shift; break; ;;
          *) echo "Internal Error!"; exit 1; ;;
        esac
      done
    }

    function main(){
      parse_params $@
    }

    main $@

环境变量：
    export XXX="true"（导出到环境变量，作用域：当前bash）
    unset XXX（取消环境变量）
    export PATH=/home/bin:$PATH（修改PATH）
    env | grep XXX（查看环境中是否有）

bash和source：
    bash main.sh：（相当于 ./main.sh）会开启子线程，不会影响当前环境变量
    source main.sh：（相当于 . ./main.sh）在当前进程中运行，会影响当前环境变量

自定义分隔符
    OLD_IFS="$IFS"
    IFS="|"
    for var in ${BUILD_CMD};do
        echo $var
    done
    IFS="$OLD_IFS"

符号
    ||：左边失败运行右边
    &&：左边成功运行右边
    |：左边的值会传给右边
    &：命令会在后台运行
    >|：强制重定向

输出
    标准错误输出到标准输出：echo "haha" > out.txt 2>&1
    标准错误输出到标准输出并且不打印：echo "haha" > /dev/null 2>&1

管道编译输出返回码
    build.sh 2>&1 | tee build.log
    ret=${PIPESTATUS[0]}

自增1
    let a+=1

调试模式
    set +x（关闭调试）
    set -x
    -e  如果一个命令以非零状态退出，则立即退出。
    -n  读取命令但不执行
    export PS4='+$LINENO: {${FUNCNAME[0]}}: '（对打印功能进行增强）

字符串前面自动补0
    echo 123 | awk '{printf("%05d\n",$0)}'
```