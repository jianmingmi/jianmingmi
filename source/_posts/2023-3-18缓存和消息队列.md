---
uuid: a0eaf650-bd80-11ed-bc52-d1984836d6a0
title: 缓存和消息队列
date: 2023-3-18
tags: [Web]
---

缓存和消息队列

<!--more-->

## 缓存

高并发三大利器：缓存、限流、降级。
对于缓存，就是让数据更接近于用户，目的是让用户的访问速度更快。

![](/images/2023-3-18缓存和消息队列/0.webp)

### 浏览器缓存
浏览器是我们网上冲浪的重要工具，为了能够让我们顺畅的冲浪，它也会帮助我们缓存一些东西，主要存放一些实时性不太敏感的数据，比如商品详情页框架、商家评分、评价、广告词等。对于实时性要求高的数据则不能使用浏览器缓存。浏览器缓存是有过期时间的，我们可以通过对响应头Expires、Cache-control进行控制。

### 客户端缓存
客户端缓存很容易理解，意思就是存放在客户端的缓存。它的使用场景不多，在我们大促的时候，为了防止瞬间流量把服务端击垮，一般会在大促来临之前把app需要访问的一些素材（如js/css/image等）提前下发到客户端进行缓存，在大促来临之际app就不需要去拉取这些素材了。另外的话还有一些兜底数据或者样式文件也会存放于客户端缓存中，在服务端异常或者网络异常的时候保证app不崩。

### CDN缓存
CDN（Content Delivery Network），即内容分发网络。它是建立并覆盖在承载网之上，由分布在不同区域的边缘节点服务器群组成的分布式网络。我们通常会将一些静态页面数据、活动页面、图片等数据存放于CDN缓存中。
CDN缓存有两种机制：推送机制（当内容变更后主动将数据推送到CDN节点）和拉取机制（先访问CDN节点，无数据的时候会从源服务器获取数据返回并存储CDN节点）
举个例子，如果你要去买汽车，你应该是到4s店去买汽车，如果4s店有你可以直接提走，如果4s店没有，那么4s店铺需要去进一批货，然后回到店铺，然后再给你。在这个case中，4s店其实就承当了一个CDN缓存节点的角色。

![](/images/2023-3-18缓存和消息队列/1.webp)

### 反向代理缓存
反向代理，我们一般情况都是指反向代理服务器Nginx。
Nginx缓存主要分为Nginx Http缓存与Nginx代理层缓存。
Nginx Http缓存提供expires、etag、if-modified-since指令来实现反向代理缓存。Nginx代理层缓存主要以Http模块与proxy_cacahe模块进行配置即可。

### 本地缓存
本地缓存，一般是指将客户机本地的物理内存划分出一部分空间用来缓冲客户机回写到服务器的数据。从全局的角度，我们可以有磁盘缓存、CPU缓存、应用缓存。

### 磁盘缓存分为读缓存和写缓存。

读缓存是指，操作系统为已读取的文件数据，在内存较空闲的情况下留在内存空间中（这个内存空间被称之为“内存池”），当下次软件或用户再次读取同一文件时就不必重新从磁盘上读取，从而提高速度。
写缓存实际上就是将要写入磁盘的数据先保存于系统为写缓存分配的内存空间中，当保存到内存池中的数据达到一个程度时，便将数据保存到硬盘中。

### CPU缓存
可以分为一级缓存（L1 Cache）、二级三级缓存（L2/L3）。当CPU要读取一个数据时，首先从L1中查找，没有的话再从L2/L3中查找，如果还没有那就从内存中查找，内存如果还没有那就从磁盘查找。查找顺序为：CPU->L1->L2/L3->内存->磁盘。

![](/images/2023-3-18缓存和消息队列/2.webp)

### 应用缓存
分为本地应用缓存与其他应用缓存。
本地应用缓存指的是本服务所使用的缓存，用Java服务来举例，又分为 堆内缓存 与 堆外缓存 。
堆内缓存，一般指的是Java堆的缓存对象，堆内缓存的好处是不需要序列化/反序列化，也是最快的缓存，缺点也很明显，缓存数据多的时候，GC（垃圾回收）的频率会增大，时间会加长。堆内缓存一般使用软引用/弱引用来引用对象，使用这两种引用的好处是当堆内存不足时，可以强制回收这部分内存，释放堆空间。堆内缓存最大的问题是重启时内存中的缓存数据会丢失，如果堆内缓存使用的多，再加上刚好流量风暴，有可能击垮应用。堆内缓存的实现一般有：Guava Cache、Ehcache等。
堆外缓存，这个听说的同学比较少，它处于Java堆之外的内存，不受GC控制，也不受限堆大小，只受限于机器内存，所以，使用它一定小心谨慎，如果处理不当它可能存在内存泄漏的风险！堆外内存需要序列化/反序列化，所以它会比堆内缓存慢一些。
其他应用缓存，指的是除了本服务之外的缓存，比如local redis cache。local redis cache指的是在本服务器上部署一组Redis，应用直接读本机获取缓存数据，多机之间利用主从机制同步数据。这种方式的优点是没有网络消耗，性能是最优的。

### 分布式缓存
如果数据量不大的情况下，使用local redis cache的架构是最优的。

使用local redis cache最大的问题是

* 单机器容量问题
* 多实例数据一致性问题
* 多实例缓存命中率降低导致回源DB
如果遇到这样的问题，那么应该将数据分片，尽可能的均匀分布到多台服务器，这便是分布式缓存。

分布式缓存常见的分片策略有：

* 节点取余
* 一致性哈希
* 虚拟槽分区
我们最常见的Redis-Cluster集群则是使用虚拟槽分区的方式来对数据分片的。

我们点到即止，对于Redis缓存相关，后面会有很多文章来专门讨论，敬请期待吧。

![](/images/2023-3-18缓存和消息队列/3.webp)

### 其他：缓存命中率
缓存命中率是我们非常重要的一个指标，我们如果使用缓存，一定需要通过监控这个指标来看缓存的工作状态。

它的计算方式为：

命中率缓存命中次数读取总次数

缓存命中率越高越好，如何提高缓存命中率呢？我们应该对于不同场景数据有不同的缓存策略，比如：

* 大促来临之际应该提前将热点数据缓存，这种方式我们称之为缓存预热或缓存热加载；
* 在case1的基础上，将热点缓存数据与普通缓存数据做数据隔离，这一点前期需要人为干预，后期需要实时热点发现；
* 将数据分类，不同类别的数据配置合适的失效时间；
* 调整缓存粒度，通常情况下缓存粒度越小缓存命中率越高；
* 增大存储容量，当容量不够的时候会触发过期策略导致部分缓存数据失效，从而影响缓存命中率；

### 缓存问题：缓存穿透
缓存穿透是指数据库和缓存都没有的数据，每次都要经过缓存去访问数据库，大量的请求有可能导致DB宕机。（强调都没有数据+并发访问）

这里我继续点到即止，后续奉上，敬请期待

### 缓存问题：缓存击穿
缓存击穿是指数据库有，缓存没有的数据，大量请求访问这个缓存不存在的数据，最后请求打到DB可能导致DB宕机。（强调单个Key过期+并发访问）

这里我继续点到即止，后续奉上，敬请期待

### 缓存问题：缓存雪崩
缓存雪崩是指数据库有，缓存没有的数据，大量请求访问这些缓存不存在的数据，最后请求打到DB可能导致DB宕机。（强调批量Key过期+并发访问）

这里我继续点到即止，后续奉上，敬请期待

### 缓存问题：缓存一致性
缓存一致性指的是缓存与DB之间的数据一致性，我们需要通过各种手段来防止缓存与DB不一致，我们要保证缓存与DB的数据一致或者数据最终一致。

这里我继续点到即止，后续奉上，敬请期待

### 缓存的其他问题
缓存的好处我们非常受益，用户的每一次请求都伴随着无数缓存的诞生，但是缓存同时也给我们带来了不小的挑战，比如在上面提到的一些疑难课题：缓存穿透、缓存击穿、缓存雪崩和缓存一致性。

除此之外，我们还会涉及到其他的一些缓存难题，如：缓存倾斜、缓存阻塞、缓存慢查询、缓存主从一致性问题、缓存高可用、缓存故障发现与故障恢复、集群扩容收缩、大Key热Key......

分布式多级缓存架构的终章，如何解决大流量、高并发这样的业务场景，取决于你能不能成为这个领域金字塔上层的高手? 能不能把这个问题思考清楚决定了你的成长速度。

[原博文](https://zhuanlan.zhihu.com/p/496696480)

## 消息队列

### 什么是消息队列

我们可以把消息队列比作是一个存放消息的容器，当我们需要使用消息的时候可以取出消息供自己使用。消息队列是分布式系统中重要的组件，使用消息队列主要是为了通过异步处理提高系统性能和削峰、降低系统耦合性。

目前使用较多的消息队列有``ActiveMQ，RabbitMQ，Kafka，RocketMQ``。

### 为什么要用消息队列

1、通过异步处理提高系统性能（削峰、减少响应所需时间）
2、降低系统耦合性

### 消息队列带来的一些问题
* 系统可用性降低： 系统可用性在某种程度上降低，为什么这样说呢？在加入MQ之前，你不用考虑消息丢失或者说MQ挂掉等等的情况，但是，引入MQ之后你就需要去考虑了！
* 系统复杂性提高： 加入MQ之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！
* 一致性问题： 我上面讲了消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了

### RocketMQ整体结构

![](/images/2023-3-18缓存和消息队列/4.png)

如上图所示，整体可以分成4个角色，分别是：Producer，Consumer，Broker以及NameServer；

#### 1.NameServer
可以理解为是消息队列的协调者，Broker向它注册路由信息，同时Client向其获取路由信息，如果使用过Zookeeper，就比较容易理解了，但是功能比Zookeeper弱；
NameServer本身是没有状态的，并且多个NameServer直接并没有通信，可以横向扩展多台，Broker会和每一台NameServer建立长连接；

#### 2.Broker
Broker是RocketMQ的核心，提供了消息的接收，存储，拉取等功能，一般都需要保证Broker的高可用，所以会配置Broker Slave，当Master挂掉之后，Consumer然后可以消费Slave；
Broker分为Master和Slave，一个Master可以对应多个Slave，Master与Slave的对应关系通过指定相同的BrokerName，不同的BrokerId来定义，BrokerId为0表示Master，非0表示Slave；

#### 3.Producer
消息队列的生产者，需要与NameServer建立连接，从NameServer获取Topic路由信息，并向提供Topic服务的Broker Master建立连接；Producer无状态，看集群部署；

#### 4.Consumer
消息队列的消费者，同样与NameServer建立连接，从NameServer获取Topic路由信息，并向提供Topic服务的Broker Master，Slave建立连接；

#### 5.Topic和Message Queue
在介绍完以上4个角色以后，还需要重点介绍一下上面提到的Topic和Message Queue；字面意思就是主题，用来区分不同类型的消息，发送和接收消息前都需要先创建Topic，针对Topic来发送和接收消息，为了提高性能和吞吐量，引入了Message Queue，一个Topic可以设置一个或多个Message Queue，有点类似kafka的分区(Partition)，这样消息就可以并行往各个Message Queue发送消息，消费者也可以并行的从多个Message Queue读取消息；

[原博文](https://blog.csdn.net/qq_32172681/article/details/102614734)