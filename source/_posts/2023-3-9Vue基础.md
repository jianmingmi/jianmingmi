---
uuid: f546af30-bd5a-11ed-90c2-51c8d7306491
title: Vue基础
date: 2023-3-9
tags:
  - Web
abbrlink: 4b668c47
---

Vue基础

<!--more-->

## nodejs和npm
```
网址
    https://nodejs.org/en/download/
node和npm
    npm是包管理器
    node是后台
安装
    linux
        安装node、npm
            sudo apt install nodejs
            sudo apt install npm
        全局包路径：/usr/local/lib/node_modules/

    windows
        下载安装包一路next
        全局包路径：C:\Users\zhao\AppData\Roaming\npm

使用
    查看版本
        node -v
        npm -v
    升级node
        sudo npm install -g n（安装n模块，-g：global）
        sudo n stable（也可以直接指定版本sudo n 8.4.0）
        sudo n（选择切换版本）
    升级npm
        npm install -g npm@9.4.0
    修改镜像源
        npm get registry
        npm config set registry https://registry.npm.taobao.org
    查看config配置
        npm config ls
    列出包名
        npm list（列出本地包，-g：全局包）
        npm fund（列出包名：详细）
    安装包和升级
        npm install element-ui -S（-s：保存到本地）
        npm install（没有指定则从：package.json 解析下载）
        npm install -g cnpm（安装cnpm，-g：全局）
        npm install -g npm@9.1.1（npm升级，-g：全局安装）
        npm install vue@2.6.14（软件安装）
        npm install vue-template-compiler@2.7.14（软件安装）
        npm install echarts --save（把依赖包名称添加到 package.json 文件 dependencies 键下）
        npm install vue --save-dev（添加到 package.json 文件 devDependencies 键下）
    卸载
        npm uninstall vue（卸载）
    查看包信息
        npm info vue（最新）
    初始化包package.json
        npm init
    包vue-cli和@vue/cli区别
        Vue CLI 的包名称由 vue-cli 改成了 @vue/cli
        npm包前面加@，代表scopes相关的包，可以理解为作用域(范围)包，作用域使我们可以创建与其他用户或组织创建的包同名，而不会发生冲突
    加载过程
        npm run dev
        npm run serve
            .env
            .env.development
        npm run build
            .env
            .env.production
    node版本号
        ~x.y.z: 匹配大于 x.y.z 的 z 的最新版
        ^x.y.z: 匹配大于 x.y.z 的 y.z 的最新版
        *: 任意版本，一般是最后一次正式发布版本（包括非 latest tag），不是最大版本号版本
        一个标准的版本号必须是X.Y.Z的形式，X是主版本，Y是副版本，Z是补丁版本。
```


## vue
```
地址
    vue2：https://v2.cn.vuejs.org/v2/guide/
    vue3：https://cn.vuejs.org/
    vue cli脚手架：https://cli.vuejs.org/zh/index.html
    vite脚手架：https://cn.vitejs.dev/
    ElementUI vue2：https://element.eleme.cn/#/zh-CN
    ElementUI vue3：https://element-plus.gitee.io/zh-CN/
Vite 和 Vue CLI
    Vue CLI，他是 Vue 2 最棒的前端构建工具，Vue CLI 基于 Webpack 之上，是 Webpack 的超集
    Vite 是 Vue 团队开发的新一代前端开发与构建工具，Vite 不是基于 Webpack 开发的

    vite启动项目
        npm create vite@latest
        npm install
        npm run dev
        npm run build（编译正式环境）
        npm run preview（运行正式环境）

    vue cli启动项目
        npm install -g @vue/cli
        vue -V
        vue create 项目名
        npm run serve启动项目

    目录介绍
        node_modules（npm 加载的项目依赖模块）
        public（公共资源）
        src（开发目录）
            api            数据请求
            pages          页面
            assets（图片等文件）
            components（组件）
            router（路由）
            store（vuex）
            views（页面）
            App.vue（核心页）
            main.js（核心文件）
        .browserslistrc（这个配置能够分享目标浏览器和nodejs版本在不同的前端工具。这些工具能根据目标浏览器自动来进行配置）
        .eslintrc.js（ESlint配置文件）
        .gitignore（git配置文件）
        babel.config.js（babel配置文件）
        package-lock.json（依赖版本锁定）
        package.json（项目信息及依赖信息）
        README.md（项目介绍）

vue语法（787原则）
    7个属性
        el：绑定id，用来指示vue编译器从什么地方开始解析 vue 的语法，可以说是一个占位符
        data：用来组织从view中抽象出来的属性，可以说将视图的数据抽象出来存放在data中
        methods：放置页面中的业务逻辑，js方法一般都放置在methods中
        computed：定义计算属性的方法
        watch：侦听器，watch:function(new,old){ … }，监听data中数据的变化，两个参数，一个返回新值，一个返回旧值
        template：用来设置模板，会替换页面元素，包括占位符
        render：创建Virtual Dom
        filters：过滤器
        props：接收数据
    8种方法
        beforeCreate() 创建实例
        created() 创建完成
        beforeMount() 创建模板
        mounted() 创建完成
        beforeUpdate() 更新状态
        updated() 更新完成
        beforeDestory() 销毁 vue 实例
        destoryed() 销毁完成
    7个指令
        v-text 在元素中插入值
        v-html 在元素中插入html标签和文本
        v-if 根据表达式的真假值来动态插入和移除元素
        v-show 根据表达式的真假值通过控制css的display来隐藏和显示元素
        v-for 根据变量的值来循环渲染元素
        v-on 监听元素事件，执行相应操作
        v-bind 绑定元素属性，执行相应操作
        v-model 绑定input值和变量，实现数据视图的双向绑定

vue使用
    插值
        文本
            <span>Message: {{ msg }}</span>
            <span v-once>这个将不会改变: {{ msg }}</span>
        原始 HTML
            <p>Using v-html directive: <span v-html="rawHtml"></span></p>
        Attribute
            <div v-bind:id="dynamicId"></div>
            <button v-bind:disabled="isButtonDisabled">Button</button>
                对于布尔 attribute (它们只要存在就意味着值为 true)，v-bind 工作起来略有不同，在这个例子中：
                如果 isButtonDisabled 的值是 null、undefined 或 false，则 disabled attribute 甚至不会被包含在渲染出来的 <button> 元素中。
        使用 JavaScript 表达式
            {{ number + 1 }}
            {{ ok ? 'YES' : 'NO' }}
            {{ message.split('').reverse().join('') }}
            <div v-bind:id="'list-' + id"></div>
    指令
        参数
            一些指令能够接收一个“参数”，在指令名称之后以冒号表示。例如，v-bind
            <a v-bind:href="url">...</a>

            一个例子是 v-on 指令，它用于监听 DOM 事件
            <a v-on:click="doSomething">...</a>
        动态参数
            从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数
            <a v-bind:[attributeName]="url"> ... </a>

            同样地，你可以使用动态参数为一个动态的事件名绑定处理函数：
            <a v-on:[eventName]="doSomething"> ... </a>
        修饰符
            例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()
            <form v-on:submit.prevent="onSubmit">...</form>

    缩写
        v-bind 缩写
            <!-- 完整语法 -->
            <a v-bind:href="url">...</a>
            <!-- 缩写 -->
            <a :href="url">...</a>
            <!-- 动态参数的缩写 (2.6.0+) -->
            <a :[key]="url"> ... </a>
        v-on 缩写
            <!-- 完整语法 -->
            <a v-on:click="doSomething">...</a>
            <!-- 缩写 -->
            <a @click="doSomething">...</a>
            <!-- 动态参数的缩写 (2.6.0+) -->
            <a @[event]="doSomething"> ... </a>

    计算属性
        <p>Original message: "{{ message }}"</p>
        <p>Computed reversed message: "{{ reversedMessage }}"</p>
        var vm = new Vue({
          el: '#example',
          data: {
            message: 'Hello'
          },
          computed: {
            // 计算属性的 getter
            reversedMessage: function () {
              // `this` 指向 vm 实例
              return this.message.split('').reverse().join('')
            }
          }
        })

    侦听器
        <input v-model="question">
        var vm = new Vue({
          el: '#example',
          data: {
            question: 'Hello'
          },
          watch: {
            question: function (newVal, oldVal) {
              this.newVal = newVal
              this.oldVal = oldVal
            }
          },
        })

    Class 与 Style 绑定
        class绑定
            <div class="static" v-bind:class="{ active: isActive, 'text-danger': hasError }"></div>
            data: {
              isActive: true,
              hasError: false
            }
            结果渲染为：
            <div class="static active"></div>

            也可以
            <div v-bind:class="classObject"></div>
            data: {
              classObject: {
                active: true,
                'text-danger': false
              }
            }

        对象语法
            <div v-bind:class="classObject"></div>
            data: {
              isActive: true,
              error: null
            },
            computed: {
              classObject: function () {
                return {
                  active: this.isActive && !this.error,
                  'text-danger': this.error && this.error.type === 'fatal'
                }
              }
            }

        数组语法
            <div v-bind:class="[activeClass, errorClass]"></div>
            data: {
              activeClass: 'active',
              errorClass: 'text-danger'
            }
            <div class="active text-danger"></div>

        style绑定
            <div v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>
            data: {
              activeColor: 'red',
              fontSize: 30
            }

            也可以
            <div v-bind:style="styleObject"></div>
            data: {
              styleObject: {
                color: 'red',
                fontSize: '13px'
              }
            }

    条件渲染
        v-if
            <h1 v-if="awesome">Vue is awesome!</h1>
            <h1 v-else>Oh no 😢</h1>

            <div v-if="Math.random() > 0.5">
              Now you see me
            </div>
            <div v-else>
              Now you don't
            </div>

            <div v-if="type === 'A'">
              A
            </div>
            <div v-else-if="type === 'B'">
              B
            </div>
            <div v-else-if="type === 'C'">
              C
            </div>
            <div v-else>
              Not A/B/C
            </div>

            <template v-if="loginType === 'username'">
              <label>Username</label>
              <input placeholder="Enter your username" key="username-input">
            </template>
            <template v-else>
              <label>Email</label>
              <input placeholder="Enter your email address" key="email-input">
            </template>
            用key=来区别控件，防止控件值复用

        v-show
            <h1 v-show="ok">Hello!</h1>
            用法大致一样。不同的是带有 v-show 的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS property display。

        v-if vs v-show
            v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。
            v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。
            相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。
            一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。

        v-if 与 v-for 一起使用
            不推荐同时使用 v-if 和 v-for。请查阅风格指南以获取更多信息。
            当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级。请查阅列表渲染指南以获取详细信息。

    列表渲染
        用 v-for 把一个数组
            <ul id="example-1">
              <li v-for="item in items" :key="item.message">
                {{ item.message }}
              </li>
            </ul>
            var example1 = new Vue({
              el: '#example-1',
              data: {
                items: [
                  { message: 'Foo' },
                  { message: 'Bar' }
                ]
              }
            })
            也可使用
            <ul id="example-2">
              <li v-for="(item, index) in items">
                {{ parentMessage }} - {{ index }} - {{ item.message }}
              </li>
            </ul>

        在 v-for 里使用对象
            <ul id="v-for-object" class="demo">
              <li v-for="value in object">
                {{ value }}
              </li>
            </ul>
            new Vue({
              el: '#v-for-object',
              data: {
                object: {
                  title: 'How to do lists in Vue',
                  author: 'Jane Doe',
                  publishedAt: '2016-04-10'
                }
              }
            })

            也可使用
            <div v-for="(value, name) in object">
              {{ name }}: {{ value }}
            </div>

    表单绑定
        你可以用 v-model 指令在表单 <input>、<textarea> 及 <select> 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素
        v-model 会忽略所有表单元素的 value、checked、selected attribute 的初始值而总是将 Vue 实例的数据作为数据来源
        v-model 在内部为不同的输入元素使用不同的 property 并抛出不同的事件
            text 和 textarea 元素使用 value property 和 input 事件；
            checkbox 和 radio 使用 checked property 和 change 事件；
            select 字段将 value 作为 prop 并将 change 作为事件。
        使用
            <input v-model="message" placeholder="edit me">
            <p>Message is: {{ message }}</p>

    v-text
        相当于原生js中的innerText
        用于将数据填充到标签中，作用于插值表达式类似，但是没有闪动问题 （如果数据中有HTML标签会将html标签一并输出 ）
        注意：此处为单向绑定，数据对象上的值改变，插值会发生变化；但是当插值发生变化并不会影响数据对象的值

        {{}}插值语法
            <!-- 可以直接写变量-->
            {{userName}}
            <!-- 可以自增 -->
            {{ number + 1 }}
            <!-- 可以写三元表达式 -->
            {{true?'男':'女'}}
            <!-- 可以调用函数  功能是倒叙-->
            {{userName.split("").reverse().join("")}}

    v-html
        用法和v-text 相似 但是它可以将HTML片段填充到标签中
        可能有安全问题, 一般只在可信任内容上使用 v-html，永不用在用户提交的内容上
        它与v-text区别在于v-text输出的是纯文本，浏览器不会对其再进行html解析，但v-html会将其当html标签解析后输出。

    组件
        传值
            templete：<h3>{{ title }}</h3>
            向组件传值：props: ['title']
            使用：<blog-post title="My journey with Vue"></blog-post>

vue其他特性
    Vue-Router 利用了浏览器自身的hash 模式和 history 模式的特性来实现前端路由（通过调用浏览器提供的接口）
        hash： 浏览器url址栏 中的 # 符号（如这个 URL：http://www.abc.com/#/hello，hash 的值为“ #/hello”），hash 不被包括在 HTTP 请求中（对后端完全没有影响），因此改变 hash 不会重新加载页面
        history：利用了 HTML5 History Interface 中新增的 pushState( ) 和 replaceState( ) 方法（需要特定浏览器支持）。单页客户端应用，history mode 需要后台配置支持

    vue路由
        通过注入路由，我们可以在任何组件内通过 this.$router 访问路由器，也可以通过 this.$route 访问当前的路由。
        注入路由，在 mian.js 中引入 路由，并且注入。
            import router from './router';
            new Vue({
              el: '#app',
              router,
              ...
              mounted() { }
            })
        在 vue 项目开发中， 我们通常使用 router.push() 实现页面间的跳转，称为编程式导航

    vuex store
        this.$store可以访问到当前store
        vuex中 this.$store.dispatch() 与 this.$store.commit()
            两个方法都是传值给vuex的mutation改变state
            this.$store.dispatch() ：含有异步操作，例如向后台提交数据，写法：this.$store.dispatch(‘action方法名’,值)
            this.$store.commit()：同步操作，，写法：this.$store.commit(‘mutations方法名’,值)

        state：相当于Vue的data
        mutations：类似于事件，每个 mutation 都有一个字符串的事件类型 (type)和 一个回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数
        actions: Action 类似于 mutation，不同在于Action 提交的是 mutation，而不是直接变更状态，Action 可以包含任意异步操作
        getters：可以认为是 store 的计算属性，就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算，接受 state 作为其第一个参数

        options 里可以有 root: true，它允许在命名空间模块里分发根的 action。返回一个解析所有被触发的 action 处理器的 Promise

    <style scoped>属性
        限制css属性只作用于当前组件

    <script setup>语法糖


组件 component
    data 必须是一个函数

@click和@click.native
    如果是普通的html，使用@click就可以触发。
    如果使用组件和路由，在router-link标签中就需要使用@click.native。不然就只会跳转而不会触发事件。

E导包
    import util from '@/libs/util'

    自动补全的扩展名：'.js', '.vue', '.json'
    @符号代表：'src'

dependencies和devDependencies
    dependencies 程序正常运行需要的包
    devDependencies 是开发需要的包

vue 和 vuex
    Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。
    Vuex 的目的是为了管理共享状态，为了达到这个目的，它制定了一系列的规则，比如修改数据源 state、触发 actions 等等，都需要遵循它的规则，以此来达到让项目结构更加清晰且易于维护的目的。
    每一个 Vuex 应用的核心就是 store（仓库）。store 基本上就是一个容器，它包含着你的应用中大部分的状态 (state)。
    其实说白了，vuex就是一个存放多个组件共用的一个数据的存放、更改、处理的一个容器，就是说来存放处理公共数据的工具，存放的数据一变，各个组件都会更新，也就是说存放的数据是响应式的

async 和 await
    async 异步调用
    await 阻塞等待

Promise对象
    Promise是一个原生的JavaScript对象，是一种异步编程的解决方案，通过一个回调,避免更多的回调

    1.promise的三个状态
    pending（初始状态、等待中）、resolved（已经成功）、rejected（已失败）。以Ajax为例：pending，就是异步还未返回结果，正在进行或者等待中，等待服务端返回结果。resolved，就是Ajax成功，rejected就是Ajax失败

    2、promise的.then方法和.catch方法
    都是是promise返回结果之后被执行的回调函数。.then接收resolved传递过来的信息;.catch接收rejected传递过来的信息

        function fn(str){  //str='日日复月月'
            //创建Promise对象
            let p = new Promise(function(resolve,reject){
                let flag = true;
                setTimeout(function(){  //模拟异步调用
                    if(flag){  //模拟异步调用成功
                        resolve(str)  //将str通过resolve传递出去 ---- resolve('日日复月月')
                    }else{  //模拟异步调用失败
                        reject("操作失败")  //将失败的信息通过reject传递出去
                    }
                })
            })
            return p;
        }

        fn('日日复月月').then((data)=>{  //.then接收resolve(str)传回来的信息
            console.log(data);  //data=('日日复月月')
            return fn('月月复年年');
        }).then((data)=>{
            console.log(data);  //data=('月月复年年')
            return fn('年年复此生')
        }).then((data)=>{
            console.log(data)  //data=('年年复此生')
        }).catch((err)=>{
            console.log(err)
        })

vue过渡动画
    <transition name="fade-scale">

vue组件缓存
    <keep-alive :include="keepAlive" v-if="showView">

```