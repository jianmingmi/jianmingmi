---
uuid: f9f9a560-bd59-11ed-9f3e-af0b7bee8afc
title: Django基础
date: 2023-3-8
tags:
  - Python
categories:
  - Python
abbrlink: '66867829'
---

Django基础

<!--more-->

## 文档

[Doc](https://docs.djangoproject.com/zh-hans/4.0)

## 说明
```
启动新项目
    django-admin startproject [project_name]

创建模块
    python manage.py startapp [app_name]
    注册模块
        settings.py 修改 INSTALLED_APPS
    添加路由
        urls.py 添加路由映射

启动
    python manage.py runserver

检查模块是否正常
    python manage.py check [app]

显示当前设置文件与Django的默认设置之间的差异
    python manage.py diffsettings

从数据库中删除所有数据
    python manage.py flush

并更新数据库
    python manage.py makemigrations
    python manage.py migrate

创建静态文件（STATIC_ROOT变量控制）
    python manage.py collectstatic

动带有Django环境的Python交互式解释器
    python manage.py shell

运行所有已安装的app的测试代码
    python manage.py test [test_label [test_label ...]]

创建超级用户 和 修改密码
    python manage.py createsuperuser
    其他内置命令
        changepassword
        clearsessions
        collectstatic
```


## MySQLdb 只适用于python2.x，。在python3.x的替代品是： import pymysql
```
解决办法：

base.py 文件同目录下的__init__.py文件新增如下两行：

vi /usr/local/python3/lib/python3.4/site-packages/django/db/backends/mysql/__init__.py

import pymysql
pymysql.install_as_MySQLdb()

如果还报如下错误：
AttributeError: module 'pymysql' has no attribute 'install_as_MySQLdb'

解决方法：
pip uninstall PyMySQL3
pip install -U --force-reinstall pymysql
```


## 一、Django的概要和安装

### 一、Django的概要
```
1.Django的介绍
    如果你来看这篇文章，想必你一定是正在学习网站开发的后端，或者想要学习网站的后端开发，选择的Django框架作为网站的后端。
    没错，Django正是一个由Python编写的网络框架，可以给开发者便利快捷的开发网站。现在国内有很多大型网站都是使用的Django这个框架，它能够承受高并发。同时，该框架本身就自带了网络安全服务。
    该框架可以在Windows、MacOS、Linux等平台运行。

2.Django的MTV
    学习Django一定要知道的东西就是MTV。需要知道MTV代表的都是什么含义。


    Views：视图。是一个请求处理函数，它就收HTTP请求并返回HTTP响应。试图通过模型访问满足请求所需要的数据，并将相应的格式给模板发去。
    Models：模型。是定义应用程序数据结构的Python对象，并提供在数据库中的管理（GET、POST、PATHCH、DELETE）和查询记录的机制。
    Templates：模板。是定义文件（如html文件）的结构或布局的文件。
    总结

    Model	Template	View
    负责业务对象和数据库的关系映射（ORM）	负责如何把页面展示给用户（html）	负责业务逻辑，并在适当时候调用Model和Template
```

### 二、Django的安装
```
Django和Python中其他的模块一样，都是通过pip指令安装。
    pip install django

查看django的版本
在cmd中输入以下指令：
    python -m django --version
```

## 二、创建第一个项目和APP
### 一、创建第一个项目
```
1.创建django项目
    有两种方式可以创建django的项目。
    一种是通过cmd进行创建，一种是通过pycharm直接创建django项目。
    在这里我只介绍一种，就是通过cmd创建django的项目，因为用pycharm创建比较简单，我就不过多介绍。
    首先我们需要知道能够创建django项目的原理。
    我们知道，我们所安装的所有python的模块，都存储在一个python文件下的叫做Scripts的文件夹下。
    我们之所以能够创建django项目，是因为我们安装django的时候，会自动安装一个py文件，叫做django-admin。


    所以我们可以通过django-admin来创建我们的django项目。
    具体方法

    打开cmd，到指定的目录下。
    输入以下指令：
    django-admin startproject my_first_django
    这样我们就成功的创建了第一个django项目。


2.django项目的文件的具体介绍
    我们创建完django项目，发现突然多了好多目录，下面就让我来细致的介绍一些这些py文件的作用。
    首先创建了一个文件夹和manage.py，然后文件夹里创建了好多文件。

    manage.py

    这个文件就是关于项目的管理、启动项目、创建APP、数据管理的文件，这个文件一定不要改动，我们经常使用这个文件。

    文件夹里的文件

    init.py：基本用不上，不用改动。
    settings.py：关于项目的配置，比如数据库的配置，访问安全检测配置等，常常需要修改。
    urls.py：定义url和函数的对应关系，常常需要修改。
    asgi.py：接受网络请求，主要是异步的请求，不需要改动。
    wsgi.py：接受网络的请求，主要是同步的请求，不需要改动。
```

### 二、创建第一个APP
```
1.什么是APP？
    app的全程就是application单词，它的含义是应用，当我们的项目足够大的时候，例如路由或者配置文件、模板文件都写在一起，比较臃肿，因此我们将所有的功能单独分成多个APP来进行开发。
    举个例子：
    比如一个完整的django项目相当于一所大学，那么APP就相当于大学中的各个学院。

2.创建APP
    首先我们需要知道能够创建django的APP的原理。
    我们需要通过manage.py这个文件来创建我们的APP。
    具体方法

    打开cmd（到我的项目的目录下）
    输入以下cmd指令：
    python manage.py startapp app01
    这样我们的app就创建成功了。


3.APP的文件的具体介绍
    创建完的app，发现又多了好多文件，所以我来介绍以下APP目录下的文件的作用。

    apps.py：固定的，不用改动。用于app的启动的类。
    migrations：固定的，不用改动。做数据库的字段变更记录的。
    test.py：固定的，不用改动，做单元测试的。
    admin.py：固定的，不用改动。django默认提供了admin后台管理。
    models.py： 对数据库进行操作。
    view.py： 定义url调用的函数。
```

## 三、Django的运行
### 一、APP的注册
```
前面讲到，我们虽然已经成功的注册了django的项目和app，但是我们的app现在仍然不能够使用，所以我们需要注册APP才可以正常使用。
具体方法

转到项目的settings文件下。

找到INSTALLED_APPS


将我们注册好的APP存放到这里。

这样，我们的APP注册工作就完成了。
```

### 二、编写URL和函数的对应关系
```
我们首先需要在urls文件里创建我们的链接，也就是访问时的路径。那么我们通过什么来连接起来呢？通过定义函数，也就是说用户访问我们定义好的链接之后，用户会执行我们定义好的函数。
```


### 三、编写视图函数
```
现在我们就需要编写我们的视图函数了，需要在views文件里来定义我们的函数的具体内容。
```


### 四、启动我们的Dajgno项目
```
有两种方式，一种是命令行启动，一种是通过pycharm来进行启动。下面我只介绍命令行启动的方式，因为我比较喜欢这种启动方式。
具体步骤

打开cmd，到项目的目录下。
输入以下指令：
python manage.py runserver

为什么会这样呢？
仔细以看，原来是我们访问的网址不对，刚才我们编写的是index/的页面，所以我们需要访问到index/的页面才可以正常的显示。


这样我们的django项目就运行起来了。
```

## models字段，ORM 对象关系映射


```
功能：根据对象的类型生成表结构，
将表结构转换为数据库语句，将数据库结果转换为对象或者表

优点：极大的简化了编程人员的工作量，统一了代码编写。

模型、属性和表、字段间的关系：一个模型对应一张表，该模型中的属性对应该模型表的字段

注意：django会自动的给每一张表设定主键，当人为的设定逐渐后django就不会添加主键
属性的命名规则：python的关键字标识符，连续的下划线不可以为属性名称

使用流程

库的导入
    django中定义的属性和模型都存放在django.db.models.files的目录下，伪类方便使用
被导入到django.db.models中
    使用方式：from django.db import models

数据的逻辑删除
    对于重要的数据我们一般定义逻辑删除，定义字段isdelete，默认属性为False

字段类型
    AutoField   一个自动增加的整数类型字段。通常你不需要自己编写它，
        Django会自动帮你添加字段：id = models.AutoField(primary_key=True)，
        这是一个自增字段，从1开始计数。如果你非要自己设置主键，
        那么请务必将字段设置为primary_key=True。
        Django在一个模型中只允许有一个自增字段，并且该字段必须为主键！

    BigAutoField    (1.10新增)64位整数类型自增字段，数字范围更大，从1到9223372036854775807


    ForeignKey      外键，关联其他的表

    CharField(max_length= n) 字符串字段，可以设定最大长度。表单textinput类型

    TextField   大量文本内容，在HTML中表现为Textarea标签，最常用的字段类型之一！
        如果你为它设置一个max_length参数，那么在前端页面中会受到输入字符数量限制，
        然而在模型和数据库层面却不受影响。只有CharField才能同时作用于两者。

    IntegerField
        整数类型，最常用的字段之一。取值范围-2147483648到2147483647。在HTML中表现为NumberInput标签。

    DecimalField
        固定精度的十进制小数。相当于Python的Decimal实例，必须提供两个指定的参数！参数max_digits：数值最大的总位数，
        必须大于或等于小数点位数 。decimal_places：小数点位数，精度。 当localize=False时，它在HTML表现NumberInput标签，
        否则是text类型。例子：储存最大不超过999，带有2位小数位精度的数，
        定义如下：models.DecimalField(..., max_digits=5, decimal_places=2)。

    FloatField
        浮点数类型，参考整数类型

    BooleanField
        布尔值类型。在HTML表单中体现为CheckboxInput标签。如果要接收null值，
        请使用NullBooleanField。

    NullBooleanField
        类似布尔字段，只不过额外允许NULL作为选项之一。

    DateField
        class DateField(auto_now=False, auto_now_add=False, **options)日期类型。
        一个Python中的datetime.date的实例。在HTML中表现为TextInput标签。在admin后台中，
        Django会帮你自动添加一个JS的日历表和一个“Today”快捷方式，以及附加的日期合法性验证。
        两个重要参数：（参数互斥，不能共存） auto_now:每当对象被保存时将字段设为当前日期，
        常用于保存最后修改时间。auto_now_add：每当对象被创建时，设为当前日期，常用于保存创建日期(注意，它是不可修改的)。
        设置上面两个参数就相当于给field添加了editable=False和blank=True属性。如果想具有修改属性，请用default参数。
        例子：pub_time = models.DateField(auto_now_add=True)，自动添加发布时间。

    TimeField
        时间字段，Python中datetime.time的实例。接收同DateField一样的参数，只作用于小时、分和秒。

    DateTimeField
        日期时间类型。Python的datetime.datetime的实例。与DateField相比就是多了小时、分和秒的显示，
        其它功能、参数、用法、默认值等等都一样。

    FileField
        class FileField(upload_to=None, max_length=100, **options)上传文件类型，后面单独介绍。

    ImageField
        图像类型

    FilePathField
        文件路径类型
        class MyModel(models.Model):
        # 文件被传至`MEDIA_ROOT/uploads`目录，MEDIA_ROOT由你在settings文件中设置
        upload = models.FileField(upload_to='uploads/')
        # 或者
        # 被传到`MEDIA_ROOT/uploads/2015/01/30`目录，增加了一个时间划分
        upload = models.FileField(upload_to='uploads/%Y/%m/%d/')
        使用FileField或者ImageField字段的步骤：
        在settings文件中，配置MEDIA_ROOT，作为你上传文件在服务器中的基本路径（为了性能考虑，这些文件不会被储存在数据库中）。
        再配置个MEDIA_URL，作为公用URL，指向上传文件的基本路径。请确保Web服务器的用户账号对该目录具有写的权限。
        添加FileField或者ImageField字段到你的模型中，定义好upload_to参数，文件最终会放在MEDIA_ROOT目录的“upload_to”子目录中。
        所有真正被保存在数据库中的，只是指向你上传文件路径的字符串而已。可以通过url属性，在Django的模板中方便的访问这些文件。
        例如，假设你有一个ImageField字段，名叫mug_shot，那么在Django模板的HTML文件中，可以使用{{ object.mug_shot.url }}
        来获取该文件。其中的object用你具体的对象名称代替。
        可以通过name和size属性，获取文件的名称和大小信息。
        安全建议
        无论你如何保存上传的文件，一定要注意他们的内容和格式，避免安全漏洞！务必对所有的上传文件进行安全检查，
        确保它们不出问题！如果你不加任何检查就盲目的让任何人上传文件到你的服务器文档根目录内，比如上传了一个CGI或者PHP脚本，
        很可能就会被访问的用户执行，这具有致命的危害。
    GenericIPAddressField
        class GenericIPAddressField(protocol='both', unpack_ipv4=False, **options)[source],IPV4或者IPV6地址，
        字符串形式，例如192.0.2.30或者2a02:42fe::4在HTML中表现为TextInput标签。
        参数protocol默认值为‘both’，可选‘IPv4’或者‘IPv6’，表示你的IP地址类型。

    PositiveIntegerField
        正整数字段，包含0,最大2147483647。
    PositiveSmallIntegerField
        较小的正整数字段，从0到32767。
    SlugField
        slug是一个新闻行业的术语。一个slug就是一个某种东西的简短标签，包含字母、数字、下划线或者连接线，
        通常用于URLs中。可以设置max_length参数，默认为50。
    SmallIntegerField
        小整数，包含-32768到32767。

    URLField
        一个用于保存URL地址的字符串类型，默认最大长度200。
    UUIDField
        用于保存通用唯一识别码（Universally Unique Identifier）的字段。使用Python的UUID类。
        在PostgreSQL数据库中保存为uuid类型，
        其它数据库中为char(32)。这个字段是自增主键的最佳替代品。

    注：CHOICES
        SEX_CHOICES = (
            (0, "男"),
            (1, "女"),
        )
        sex = models.IntegerField(choices=SEX_CHOICES, default=0, verbose_name="性别")

字段选项
    null= 为True 空值，储存到数据库中null 默认值False
    blank= 为True，允许空白默认值为false
    db_column= string更改属性在数据表中的名称
    db_index=  True添加一个索引
    default   默认值
    primary_key 主键
    unique  唯一值，不可相同

关系
    ForeignKey  一对多关系，定义在多的一方
    ManyToManyField 多对多关系，定义在第三方表
    OneToOneField 一对一关系，定义在任意一方即可

一访问多
    对象名.小写模型名_set
    grades.students_set

一访问一
    对象名.小写模型名
    grades.student

访问id值
    对象名.属性_id
    grades.students_id

元类选项
    定义class Meta：
        类定义属性db_table = string 更改表名
        排序属性ordering = ['id'] 默认为升序 -id为降序
    注意：ordering会增加数据库的开销

模型成员之管理器
    类属性 objects 是一个manager对象与数据库交互数据
    当没有定义管理器的时候django会为模型添加objects管理器

    自定义管理器：
        定义后django就不会创建objects对象
        stuobj = models.Manager()
        作用：
        1.添加新的方法
        2.修改原始查询数据，重写get_queryset()方法
            # 重写模型管理器对象方法
            class StudentManager(models.Manager):
                # 重新定义查询函数，保留isdelete=false的数据
                def get_queryset(self):
                    return super(StudentManager, self).get_queryset().\
                        filter(isdelete= False)
            class Students(models.Model):
                # 创建stuobj管理器
                stuobj = models.Manager()
                stuobj2 = StudentManager()

创建对象
    功能：向数据库中添加数据，创建对象不会向数据库添加数据，调用save()才会添加数据
    __init__在父类models.Model中使用，自定义对象不可使用

创建方法
    模型中添加一个类方法
        #     创建类方法,添加类数据
        @classmethod
        def createStudent(cls, sname, sage, sgender, sbirth, sgrade, isdelete= False):
            stu = cls(name= sname, age= sage, gender= sgender, birth= sbirth,
                      grade= sgrade, isdelete= isdelete)
            stu.save()
        再到views.py文件中定义相关的功能函数
            # 调用类方法添加属性
            def addstudent(myrequest):
               grade = Grades.objects.get(pk= 1)
               Students.createStudent('lilei',20,True,'1989-11-15 08:30:33', grade)
               return HttpResponse("Successfully !")
    定义管理器中添加一个方法
            # 重写模型管理器对象
            class StudentManager(models.Manager):
                # 重新定义查询函数，保留isdelete=false的数据
                def get_queryset(self):
                    return super(StudentManager, self).get_queryset().\
                        filter(isdelete= False)

                def createStudent(self, sname, sage, sgender, sbirth, sgrade, isdelete=False):
                    # 创建模型对象
                    stu = self.model()
                    stu.age = sage
                    stu.name = sname
                    stu.birth = sbirth
                    stu.gender = sgender
                    stu.grade = sgrade
                    stu.isdelete = isdelete
                    stu.save()

查询模型
    功能：对数据库中的数据进行田间查询，查询器可以有多个过滤器
    查询基函数方法：
        all()
                获取全部的数据集合对象
        filter()
                获取复合条件的数据集合
                filter(键=值)
                filter(键=值， 键=值)
                filter(键=值).filter(键=值)
        exclude()
                过滤掉复合条件的数据集
        order_by()
                排序
        values()
                返回字典为元素的列表，每个字典包含一个对象数据

    单个数据返回的函数：
            get()   没找到数据或者找到多个数据都会发生异常
            count() 返回查询集的对象个数
            first() 返回查询集的第一个对象
            last()  返回查询集的最后一个对象
            exists() 返回布尔值，判断数据集中是否有数据对象

    返回有限的数据集数据对象
            由于数据集合是由列表展现在出来的，所以可以用角标提取[a:b],角标不可用负数。

    查询集的缓存概念：每次的查询都会保留缓存，除了第一次为空，是为了提高查询的效率

    逻辑查询字段
        相当于filter，exclude，get等函数的参数
        语法： 属性名__比较运算符=值   双下划线
        外键： 属性名_id=值
        转义： % _ 等特殊符号直接被转义为一般符号

        比较运算符：
            exact 判断 filter(isdelete=False)大小写敏感
            contains 包含 students.stuobj2.fliter(name__contain='sun')
            startswith和endswith  以什么卡头或结尾  students.stuobj2.fliter(name__startswith='sun')
            前面加上i就不存在大小写敏感  iexact， icontains，istartswith， iendswith
            isnull isnotnull  是否为空 filter(name__isnull= False)
            in 是否在指定的范围内 students.stuobj2.filter(pk__in= [2,4,6,8,10])
            gt,gte,lt,lte 大于，大于等于，小于，小于等于
            year,month,day,week_day,hour,minute,second时间上的判断


        聚合函数
            使用aggregate（）函数返回聚合函数的值
            Max
            Min
            Sum
            Avg
            Count

            from django.db.model import Max
            # 返回最大的年龄数值
            Students.stuobj2.aggregate(Max('age'))

        F对象    对象内部属性值的相互比较
            from django.db.models import F,Q
            #F对象的使用,模型内部的属性值间的比较，查询男生小于女生的班级
            # stu = Grades.objects.filter(girlsnum__gt= F('boysnum'))
            # F对象的数学运算使用
            stu = Grades.objects.filter(girlsnum__gte= F('boysnum') + 20)

        Q对象    用于对象内部属性值间的或比较需求
            #     选择班级为1和2的学生
            stu = Students.stuobj2.filter(Q(grade= 1) | Q(grade= 2))
            #     选择班级不为1的学生
            stu = Students.stuobj2.filter(~Q(grade= 1))
        跨关联查询
            #      在班级表中查询学生名字有Lucy的班级
            stu = Grades.objects.filter(students__name__contains= 'lucy')
```

## 部署asgi daphne
```
启动
    sudo vim /etc/supervisor/conf.d/django.conf
        [program:django]
        user=android
        directory=/home/android/service/WebSCM
        command=bash -c "/usr/local/python3.8.5/bin/daphne -b 127.0.0.1 -p 8080 core.asgi:application"
        autostart=true
        autorestart=true
        redirect_stderr=true
        stdout_logfile=/home/android/service/WebSCM/django.output

        [program:celery_worker_default]
        user=android
        directory=/home/android/service/WebSCM
        command=bash -c "/usr/local/python3.8.5/bin/celery -A core worker -l info -Q default -c 10"
        autostart=true
        autorestart=true
        redirect_stderr=true
        stdout_logfile=/home/android/service/WebSCM/celery.worker.default.output

        [program:celery_worker_jenkins]
        user=android
        directory=/home/android/service/WebSCM
        command=bash -c "/usr/local/python3.8.5/bin/celery -A core worker -l info -Q jenkins_queue -c 1"
        autostart=true
        autorestart=true
        redirect_stderr=true
        stdout_logfile=/home/android/service/WebSCM/celery.worker.jenkins.output

        [program:celery_beat]
        user=android
        directory=/home/android/service/WebSCM
        command=bash -c "/usr/local/python3.8.5/bin/celery -A core beat -l info"
        autostart=true
        autorestart=true
        redirect_stderr=true
        stdout_logfile=/home/android/service/WebSCM/celery.beat.output

    sudo service supervisor restart（重启）
    sudo service supervisor status（查看状态）

nginx配置
    server {
        listen 80;
        listen [::]:80;

        server_name web_scm_service;

        client_max_body_size     50m;
        client_header_timeout    1m;
        client_body_timeout      1m;
        proxy_connect_timeout     60s;
        proxy_read_timeout      1m;
        proxy_send_timeout      1m;

        location / {
           try_files $uri @proxy_to_app;
        }

        location @proxy_to_app {
            proxy_pass http://127.0.0.1:8080;

            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";

            proxy_redirect off;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Host $server_name;
        }

        location /static {
            alias /home/android/service/WebSCM/static;
        }
    }
```


## 部署uwsgi
```
安装uwsgi
    sudo pip3 install uwsgi

安装nginx
    sudo apt install nginx

uwsgi配置文件
    [uwsgi]
    #套接字方式--使用nginx连接时使用,后面是Django程序所在服务器地址
    # socket=192.168.0.214:8000

    #http通信方式--直接做web服务器使用,后面是Django程序所在服务器地址
    socket=127.0.0.1:8091

    #配置当前工作的项目目录
    chdir=/data/web/WebGame

    #项目中wsgi.py文件的目录，相对于项目目录
    wsgi-file=core/wsgi.py

    # 进程数
    processes=2

    # 线程数
    threads=2

    # 开启主进程模式--uwsgi服务器的角色   uwsgi做主进程,关闭该进程其他相关进程也会被杀掉
    master=True

    # 存放进程编号的文件
    pidfile=uwsgi.pid

    # 后台运行,并输出日志，后面是日志文件位置，后台运行时看不见终端所以只能查看日志
    daemonize=uwsgi.log

uwsgi启动和停止
    启动：uwsgi --ini uwsgi.ini
    停止：uwsgi --stop uwsgi.pid
    重启：uwsgi --reload xxx.pid

nginx配置代理
    server {
        listen 8081;

        listen [::]:8081;

        server_name web_game_service;

        client_max_body_size     50m;
        client_header_timeout    1m;
        client_body_timeout      1m;
        proxy_connect_timeout     60s;
        proxy_read_timeout      1m;
        proxy_send_timeout      1m;

        location / {
            include  uwsgi_params;
            uwsgi_pass  127.0.0.1:8091;
        }

        location /static {
            alias /data/web/WebGame/static;
        }
    }
```

## 外键
```
在MySQL中，表有两种引擎，一种是InnoDB，另外一种是myisam。如果使用的是InnoDB引擎，是支持外键约束的。外键的存在使得ORM框架在处理表关系的时候异常的强大。MySQL数据库默认使用的也是InnoDB引擎。

使用外键
新建一个项目，创建一个article的app，添加至settings中，并且在settings中设置数据库的连接，调至整个项目能运行为止。

类定义为class ForeignKey(to,on_delete,**options)。第一个参数是引用的是哪个模型，第二个参数是在使用外键引用的模型数据被删除了，这个字段该如何处理，比如有CASCADE、SET_NULL等（外键删除各个参数的意思）。这里以一个实际案例来说明。比如有一个Category和一个Article两个模型。一个种类下可以包含多篇文章，一个Article只能有一个种类，并且通过外键进行引用。那么相关的示例代码如下：

1. 在同一个app中使用外键
在article中的models中写入代码：

from django.db import models

# Create your models here.
class Category(models.Model):
    name = models.CharField(max_length=100)

class Article(models.Model):
    title = models.CharField(max_length=100)
    content = models.TextField()
    # 是由Category影响Article
    category = models.ForeignKey('Category',on_delete=models.CASCADE)
这里我们就在Article中设置了一个外键category。

以上使用ForeignKey来定义模型之间的关系。即在article的实例中可以通过category属性来操作对应的Category模型。这样使用起来非常的方便。示例代码如下：views中写入

from django.shortcuts import render
from . import models
from django.http import HttpResponse

# Create your views here.
def index(request):

    # 插入数据
    # article = models.Article(title='abc',content='111')
    # category = models.Category(name='最新文章')
    # category.save()
    # article.category = category
    # article.save()

    #读取数据
    article = models.Article.objects.first()
    print(article.category.name)
    return HttpResponse('successful')
在上面代码中把相应的注释去了，就能够进行测试了。

为什么使用了ForeignKey后，就能通过category访问到对应的Catrgory对象呢。因此在底层，Django为Article表添加了一个属性名_id的字段（比如category的字段名称是category_id），这个字段是一个外键，记录着对应的种类的主键。以后通过article.category访问的时候，实际上是先通过category_id找到对应的数据，然后再提取Category表中的这条数据，形成一个模型。


外间删除操作的参数意思：
如果一个模型使用了外键。那么在对方那个模型被删掉后，该进行什么样的操作。可以通过on_delete来指定。可以指定的类型如下：

CASCADE：级联操作。如果外键对应的那条数据被删除了，那么这条数据也会被删除。
PROTECT：受保护。即只要这条数据引用了外键的那条数据，那么就不能删除外键的那条数据。如果我们强行删除，Django就会报错。
SET_NULL：设置为空。如果外键的那条数据被删除了，那么在本条数据上就将这个字段设置为空。如果设置这个选项，前提是要指定这个字段可以为空。
SET_DEFAULT：设置默认值。如果外键的那条数据被删除了，那么本条数据上就将这个字段设置为默认值。如果设置这个选项，== 前提是要指定这个字段一个默认值 ==。
SET()：如果外键的那条数据被删除了。那么将会获取SET函数中的值来作为这个外键的值。SET函数可以接收一个可以调用的对象（比如函数或者方法），如果是可以调用的对象，那么会将这个对象调用后的结果作为值返回回去。== 可以不用指定默认值 ==
DO_NOTHING：不采取任何行为。一切全看数据库级别的约束。
以上这些选项只是Django级别的，数据级别依旧是RESTRICT！

数据库层面的约束有四种：

RESTRICT：默认的选项，如果想要删除父表的记录时，而在子表中有关联该父表的记录，则不允许删除父表中的记录；
NOACTION：同 RESTRICT效果一样，也是首先先检查外键;
CASCADE：父表delete、update的时候，子表会delete、update掉关联记录；
SET NULL:父表delete、update的时候，子表会将关联记录的外键字段所在列设为null，所以注意在设计子表时外键不能设为not null；

注：
    django外键主要是一对一的方案
    主从表主要是一对多的方案
```

## JWT
```
全称 JSON web token
先说说要后端要保存token或者session的做法是怎么样的：
    首先是用户登录，当我们校验完用户身份后，我们在缓存里或者数据库里的登录表里写上用户的信息和过期时间，然后导出一个登录id给用户使用。
    当用户再次访问时，带上这个登录id上来，你用这个id从登录表里查到用户信息进行校验，然后进行业务。
    诶，那现在我不想维护一个登录表了，要怎么搞？
    简单呀，直接把用户信息发给客户端，让客户端每次把用户信息都带过来，这样请求一进来，连表都不用查，直接就知道是哪个用户在请求。

加个密呗，简单点的能自己解开就可以了。复杂点搞个私钥自己在服务器里面玩解密加密。
这样，中间人老哥们拿到密文，一时半会也解不开，破解成本也高，大概率大大咧咧地走了。
留下一小部分有备(KPI)而来的老哥还在苦苦地想方设法破解你的密文。
这样你一解密，你就拿到用户信息了，同样的，你把过期时间也写进密文里面，遇到过期就401跳登录页。这样，一个不需要后端存储登录凭证的方案就出炉咯。
```

## DRF
```
教程
    https://blog.csdn.net/litaimin/article/details/122976825
    https://blog.csdn.net/weixin_43924621/article/details/119305558
安装
    pip install djangorestframework
配置
    INSTALLED_APPS = [
        ...
        'rest_framework',
    ]
添加路由
    urlpatterns = [
        ...
        path('api-auth/', include('rest_framework.urls'))
    ]
写view
    from django.urls import path, include
    from django.contrib.auth.models import User
    from rest_framework import routers, serializers, viewsets

    class UserSerializer(serializers.HyperlinkedModelSerializer):
        class Meta:
            model = User
            fields = ['url', 'username', 'email', 'is_staff']

    class UserViewSet(viewsets.ModelViewSet):
        queryset = User.objects.all()
        serializer_class = UserSerializer

    router = routers.DefaultRouter()
    router.register(r'users', UserViewSet)

    urlpatterns = [
        path('', include(router.urls)),
        path('api-auth/', include('rest_framework.urls', namespace='rest_framework'))
    ]
```

## django forms使用
```
from django import forms
class StudentForm(forms.Form):
    name = forms.CharField(max_length=16, required=True, min_length=2,
                           error_messages={'max_length': '名字最长为16',
                                           'min_length': '名字最短为2',
                                           'required': '名字必填'})
    age = forms.IntegerField(max_value=30, min_value=10,
                             error_messages={'max_value': '年龄最大为30',
                                             'min_value': '年龄最小为10'})
    gender = forms.BooleanField(required=False, error_messages={'required': '性别必填'})
    g = forms.ModelChoiceField(queryset=Grade.objects.all(), error_messages={'queryset': '没有这个班级'})
    c = forms.ModelMultipleChoiceField(queryset=Course.objects.all(), error_messages={'queryset': '不存在这个课程'})

form = StudentForm(json.loads(request.body))
if not form.is_valid():
    return JsonResponse({'code': 200, 'msg': form.errors})
```

## celery + redis 实现任务异步、消息队列
```
安装库 celery
    sudo pip3 install celery
配置settings（settings.py同级）
    # Broker配置，使用Redis作为消息中间件
    CELERY_BROKER_URL = "redis://:123456@192.168.33.60:6379/1"
    # BACKEND配置，这里使用redis
    CELERY_RESULT_BACKEND = "redis://:123456@192.168.33.60:6379/2"
    # 结果序列化方案
    CELERY_RESULT_SERIALIZER = 'json'
    # 任务结果过期时间，秒
    CELERY_TASK_RESULT_EXPIRES = 60 * 60 * 24
    # 时区配置
    CELERY_TIMEZONE = 'Asia/Shanghai'
    # 指定导入的任务模块，可以指定多个
    # CELERY_IMPORTS = (
    #    'other_dir.tasks',
    # )
配置celery.py（settings.py同级）
    from __future__ import absolute_import, unicode_literals
    from celery import Celery
    import os
    # 配置默认的django settings模块配置给celery
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'core.settings')
    app = Celery('core')
    # 命名空间
    namespace = 'CELERY'
    app.config_from_object('django.conf:settings', namespace='CELERY')
    # 如果你把所有的task都定义在单独的tasks.py模块中，加上这句话celery会自动发现这些模块中的task，
    app.autodiscover_tasks()
配置__init__.py（settings.py同级）
    from __future__ import absolute_import, unicode_literals
    from .celery import app as celery_app
    __all__ = ['celery_app']
配置tasks.py（settings.py同级）
    from celery import shared_task
    @shared_task
    def do_task():
        time.sleep(20)
        return "success"
调用
    from .tasks import do_task
    res = do_task.delay()
    print(res.task_id)
启动redis
    sudo pop3 install gevent
    celery -A core worker -l info -P gevent
    celery -A core beat -l info
```

## django-vue-admin
```
地址
    https://django-vue-admin.com/
    https://d2-crud-plus.docmirror.cn/d2-crud-plus/d2-crud-x/（d2-curd-x）
    https://d2-crud-plus.docmirror.cn/d2-crud-plus/guide/（d2-crud-plus）
    https://d2.pub/zh/doc/d2-admin/（d2-admin）

环境
    Python >= 3.8.0 (推荐3.9+版本)
    nodejs >= 14.0 (推荐最新)
    Mysql >= 5.7.0 (可选，默认数据库sqlite3，推荐8.0版本)
    Redis(可选，最新版)

后端运行
    进入后端项目目录:cd backend
    在项目根目录中，复制 ./conf/env.example.py 文件为一份新的到 ./conf/env.py 下，并重命名为env.py
    在 env.py 中配置数据库信息(默认数据库为sqlite3，测试演示可忽略此步骤)
    安装依赖环境: pip install -r requirements.txt
    执行迁移命令: python manage.py makemigrations; python manage.py migrate
    初始化数据: python manage.py init
    初始化省市县数据: python manage.py init_area
    启动项目: python manage.py runserver 0.0.0.0:8000

前端运行
    进入前端项目目录 cd web
    安装依赖 npm install --registry=https://registry.npm.taobao.org
    启动服务 npm run dev

访问项目
    访问地址：http://localhost:8080 (opens new window)(默认为此地址，如有修改请按照配置文件)
    账号：superadmin 密码：admin123456
```