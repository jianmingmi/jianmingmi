---
title: C基础
date: 2016-10-16
tags: [C]
---

C基础

<!--more-->

```
/* --------------------------------------c基础--------------------------------------- */
1 简介
1.1 创始时间：1972
1.2 标准：K&R、C90、C99、C11（1978年、1990年、1999年、2011年）

2 基础
2.2 数据类型（标 关 常 变 基）
2.2.1 标志符：自己可以取名字的地方称为标志符
标志符的规则（驼峰命名）
* 只能是字母，数字，下划线；
* 不能以数字开头;严格区分大小写；
* 不能使用关键字作为标志符；

2.2.2 关键字：关键字都是小写
const：
const修饰指针变量时：
　　(1)位于*左侧，表示指针所指数据是常量，不能修改该数据
　　(2)位于*右侧，表示指针本身是常量，不能指向其他内存地址

const修饰函数时：
不能修改成员数据
不能调用非const成员函数
register：请求将变量放入cpu寄存器中，速度最快

extern：标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。

explicit：避免构造函数的参数自动转换为类对象(强制显示转换)

2.2.3 常量：如123，"hello"
 
2.2.4 变量：变量的本质是内存中的一小块区域，用这个区域保存数据
* 变量必须先声明，再赋值，再使用
* 变量的作用域，局部变量与成员变量：变量在哪个大括号里定义，就在哪里有效，出了大括号无效

2.2.5 基本数据类型
char
bool
void
short int、int、long int、long long int
float、double、long double
注：
* char、bool占一个字节
* 0xff、'\xff'都可以赋值给char，因为存到内存里都是二进制
* 0xff、'\xff'都表示16进制

2.2 运算符

2.3 流程控制
2.3.1 流程控制语句：
* 顺序（continue,break,return）、分支（if,switch）、循环(for,while,do while)

2.3.2 break,continue,return
* break，continue一般用在循环中，也可以用在switch中
* break：跳出最近的整个循环（结束循环）
* continue：跳过最近整个循环的本次循环，进入下一次循环
* return：结束整个方法，或带参返回方法体
3 字符串
strlen()
strncat()
strncmp()
strncpy()


/* --------------------------------------备忘录--------------------------------------- */
SDL检查（安全开发生命周期）：
增加了更严格的编译时检查，对于废弃和不安全的函数会报error而不是warning
不让你用scanf之类的函数，必须用scanf_s

/* --------------------------------------大小端对其--------------------------------------- */
小端：较高的有效字节存放在较高的的存储器地址，较低的有效字节存放在较低的存储器地址。
大端：较高的有效字节存放在较低的存储器地址，较低的有效字节存放在较高的存储器地址。
注意 最小存储单元是byte 大小端一般针对32位数据而言的；比如int 型 0x2c3b4a6f 
从地址0x00000001开始存储 一个字节对应一个地址
地址			小段		大端
0xff000001	6f		2c
0xff000002	4a		3b
0xff000003	3b		4a
0xff000004	2c		6f


/* --------------------------------------数据加密--------------------------------------- */
加密的原理： 用密钥对原文做  异或，置换，代换，移位
1.可逆加密
Base64
2.单向加密
MD5、sha-1、RIPEMD、Haval
3.对称加密
AES、DES、3DES、TDEA、Blowfish、RC2、RC4、RC5、IDEA、SKIPJACK
4.非对称加密（只有持有私钥方的才是收到不可解密的密文）
RSA、Elgamal、背包算法、Rabin、D-H、ECC（椭圆曲线加密算法）等


/* --------------------------------------静态库和动态库--------------------------------------- */
1)静态库
需要头文件和lib文件
1.头文件作用是编译调用
2.lib文件中包含了头文件接口以及函数的具体实现

2)动态库
* 隐式调用
编译程序时需要头文件、lib文件，运行时需要DLL文件，并且运行过程中DLL文件一直被占用。适用于动态库比较少的情况。
1.头文件作用是编译调用
2.lib文件中包含了头文件在dll中的说明
注：使用文件中一般这么写
#pragma comment(lib,"../lib/Project2.lib")  注：此lib相对于链接的路径，即cpp文件
3.dll文件中包含了函数的具体实现

注：导出文件中一般这么写
#ifdef DLL_EXPORT
#define DECLDIR __declspec(dllexport)
#else
#define DECLDIR __declspec(dllimport)
#endif

DECLDIR int add(int a, int b);
class DECLDIR User
{
User(void);
~User(void);
virtual void doxxx();
};

* 显式调用
编译时什么都不需要（如果基类在库中，也需要lib库文件），在需要使用DLL中的函数时，通过LoadLibrary()和FindProcAdress()这两个API调用。只需要一个DLL文件即可，而且在需要使用的时候DLL才被占用，使用完毕即被解除占用。适用于动态库比较多的情况。
1.头文件作用是编译调用（一般函数导出用不到，类需要用到）
2.lib文件中包含了头文件接口（一般函数导出用不到，类需要用到）
3.dll文件中包含了函数的具体实现

注：导出文件中一般这么写
#ifdef DLL_EXPORT
#define DECLDIR __declspec(dllexport)
#else
#define DECLDIR __declspec(dllimport)
#endif

extern "C"
{
DECLDIR User* createObject(void)
{
return new User();
}
}

注：使用文件中一般这么写
typedef User* (*P_Fun)(void);
HINSTANCE hinst = LoadLibrary("Project2.dll");  注：需要windows.h
P_Fun p_fun = (P_Fun)GetProcAddress(hinst , "createObject");
User* user = (*p_fun)();
user->doxxx();
delete user;
FreeLibrary(h);


/* --------------------------------------静态、常量、静态常量--------------------------------------- */
类中静态以及常量的用法
1.只有静态常量整型数据成员才可以在类中初始化(包括bool、char)
2.静态变量的初始化写在类外部
3.常量的初始化写在初始化列表
注：静态方法不能访问this指针

其他用法
静态或常量可以写在namesapce中，方法不能为静态的


/* --------------------------------------枚举--------------------------------------- */

class A
{
public:
	A();
	~A();

	enum SEX
	{
		NAN,
		NV,
	};
	static SEX s;
private:

};

A::SEX A::s = A::SEX::NAN;

void swi_sex(A::SEX& temp)
{
	switch (temp)
	{
	case A::SEX::NAN:
		cout << "NAN" << endl;
		break;
	case A::SEX::NV:
		cout << "NV" << endl;
		break;
	default:
		break;
	}
}

void test()
{
	//A::s = A::SEX::NV;
	swi_sex(A::s);
}


/* --------------------------------------命名空间--------------------------------------- */
区别于复合域、类域、全局域的一块空间
在类作用域和全局作用域之间

namespace 
{
	int i = 5;
}

namespace kkk
{
	int i = 6;
	void show()
	{
		cout << "hello" << endl;
	}
}

int main()
{
	namespace ns = kkk;
	ns::show();
}
（1）一个命名空间可以在多个头文件或源文件中实现，成为分段定义。如果想在当前文件访问定义在另一个文件中的同名命名空间内的成员变量，需要在当前文件的命名空间内部进行申明。如标准C++库中的所有组件都是在一个被称为std的命名空间中声明和定义的。这些组件当然分散在不同的头文件和源文件中。
（2）命名空间内部可以定义类型、函数、变量等内容，但命名空间不能定义在类和函数的内部。
（3）在一个命名空间中可以自由地访问另一个命名空间的内容，因为命名空间并没有保护级别的限制。
（4）虽然经常可以见到using namespace std;这样的用法，我们也可以用同样的方法将命名空间中的内容一次性“引入”到当前的命名空间中来，但这并不是一个值得推荐的用法。因为这样做的相当于取消了命名空间的定义，使发生名称冲突的机会增多。所以，用using单独引入需要的内容，这样会更有针对性。例如，要使用标准输入对象，只需用using std::cin;就可以了。
（5）不能在命名空间的定义中声明另一个嵌套的子命名空间，只能在命名空间中定义子命名空间。
（6）命名空间的成员，可以在命名空间的内部定义，也可以在命名空间的外部定义，但是要在命名空间进行声明。 
命名空间成员的外部定义的格式为：命名空间名::成员名 ……
（7）命名空间在进行分段定义时，不能定义同名的变量，否则连接出现重定义错误。因为命名空间不同于类，具有外部连接的特性。由于外部连接特性，请不要将命名空间定义在头文件，因为当被不同的源文件包含时，会出现重定义的错误。


/* --------------------------------------模板函数--------------------------------------- */
template<typename T, typename P>
T xxx(T arg1,P arg2)
{
	return arg1 + arg2;
}


/* --------------------------------------__int32--------------------------------------- */
typedef __int32 common_int;				// 定义32位的int，防止编译器对int长度定义的不同
typedef unsigned __int32 common_uint;		// 定义无符号32位的int


/* --------------------------------------#define和typedef--------------------------------------- */
#define DLL_API  __declspec(dllexport)		切记：没有=，没有分号
单纯的替换
typedef char* PCHAR;
定义一种类型


/* --------------------------------------引用--------------------------------------- */

一、引用简介
　　引用就是某一变量（目标）的一个别名，对引用的操作与对变量直接操作完全一样。
　　引用的声明方法：类型标识符 &引用名=目标变量名；
　　【例1】：int a; int &ra=a; //定义引用ra,它是变量a的引用，即别名
　　说明：
　　（1）&在此不是求地址运算，而是起标识作用。
　　（2）类型标识符是指目标变量的类型。
　　（3）声明引用时，必须同时对其进行初始化。
　　（4）引用声明完毕后，相当于目标变量名有两个名称，即该目标原名称和引用名，且不能再把该引用名作为其他变量名的别名。
　　 ra=1; 等价于 a=1;
　　（5）声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。故：对引用求地址，就是对目标变量求地址。&ra与&a相等。
　　（6）不能建立数组的引用。因为数组是一个由若干个元素所组成的集合，所以无法建立一个数组的别名。
　　三、引用总结
　　（1）在引用的使用中，单纯给某个变量取个别名是毫无意义的，引用的目的主要用于在函数参数传递中，解决大块数据或对象的传递效率和空间不如意的问题。
　　（2）用引用传递函数的参数，能保证参数传递中不产生副本，提高传递的效率，且通过const的使用，保证了引用传递的安全性。
　　（3）引用与指针的区别是，指针通过某个指针变量指向一个对象后，对它所指向的变量间接操作。程序中使用指针，程序的可读性差；而引用本身就是目标变量的别名，对引用的操作就是对目标变量的操作。
　　（4）使用引用的时机。流操作符<<和>>、赋值操作符=的返回值、拷贝构造函数的参数、赋值操作符=的参数、其它情况都推荐使用引用。


/* --------------------------------------返回值--------------------------------------- */
千言万语，汇成一句话，函数不要返回指向栈的内存地址，切记，是地址，别被吓的所有的函数内的变量都不敢返回，只要不是栈的内存地址，你尽管放心的返回。
非指针、引用类型返回，会进行赋值或者拷贝操作。下面两种特殊情况。

char *pstr = "This is the buffer text";
c类型字符串存在常量区，可以返回
char buffer[] = "This is the buffer text";
数组存在栈区，返回会出问题，系统自动销毁那块内存



/* --------------------------------------数组的定义和初始化--------------------------------------- */
一、一维数组
静态 int array[100]; 　　定义了数组array，并未对数组进行初始化
静态 int array[100] = {1，2}；　　定义并初始化了数组array
动态 int* array = new int[100];  delete []array;　　分配了长度为100的数组array 
动态 int* array = new int[100](1，2); 　delete []array;　为长度为100的数组array初始化前两个元素
 
二、二维数组
静态 int array[10][10];　　定义了数组，并未初始化
静态 int array[10][10] = { {1,1} , {2,2} };　　数组初始化了array[0][0,1]及array[1][0,1]
动态 int (*array)[n] = new int[m][n]; delete []array;
动态 int** array = new int*[m];　for(i) array[i] = new int[n];  for(i) delete []array[i]; delete []array;    多次析构
动态 int* array = new int[m][n];  delete []array;      数组按行存储
 
三、多维数组
　　int* array = new int[m][3][4];    只有第一维可以是变量，其他维数必须是常量，否则会报错
      delete []array;       必须进行内存释放，否则内存将泄漏
 
 
四、数组作为函数形参传递
一维数组传递：
　　void func(int* array);
　　void func(int array[]);　　　　
二维数组传递：
　　void func(int** array);
　　void func(int (*array)[n]);　　　　　　　　　　　　　　　　　　
数组名作为函数形参时，在函数体内，其失去了本身的内涵，仅仅只是一个指针，而且在其失去其内涵的同时，它还失去了其常量特性，可以作自增、自减等操作，可以被修改。

五、字符数组
char类型的数组被常委字符数组，在字符数组中最后一位为转移字符'\0'（也被成为空字符），该字符表示字符串已结束。在C++中定义了string类，在Visual C++中定义了Cstring类。
字符串中每一个字符占用一个字节，再加上最后一个空字符。如：
char array[10] = "cnblogs";
虽然只有7个字节，但是字符串长度为8个字节。
 
也可以不用定义字符串长度，如：
char array[] = "cnblogs";

 
/* --------------------------------------指针数组和数组指针--------------------------------------- */

int* a[4]     指针数组     
                 表示：数组a中的元素都为int型指针    
                 元素表示：*a[i]   *(a[i])是一样的，因为[]优先级高于*
int (*a)[4]   数组指针     
                 表示：指向数组a的指针
                 元素表示：(*a)[i]  


/* --------------------------------------stl--------------------------------------- */


一、STL简介
STL（Standard Template Library，标准模板库)是惠普实验室开发的一系列软件的统称。它是由Alexander Stepanov、Meng Lee和David R Musser在惠普实验室工作时所开发出来
的。现在虽说它主要出现在C++中，但在被引入C++之前该技术就已经存在了很长的一段时间。
 
STL的代码从广义上讲分为三类：algorithm（算法）、container（容器）和iterator（迭代器），几乎所有的代码都采用了模板类和模版函数的方式，这相比于传统的由函数和类
 
组成的库来说提供了更好的代码重用机会。在C++标准中，STL被组织为下面的13个头文件：<algorithm>、<deque>、<functional>、<iterator>、<vector>、<list>、<map>、
<memory>、<numeric>、<queue>、<set>、<stack>和<utility>。 
二、算法
大家都能取得的一个共识是函数库对数据类型的选择对其可重用性起着至关重要的作用。举例来说，一个求方根的函数，在使用浮点数作为其参数类型的情况下的可重用性肯定比
使用整型作为它的参数类性要高。而C++通过模板的机制允许推迟对某些类型的选择，直到真正想使用模板或者说对模板进行特化的时候，STL就利用了这一点提供了相当多的有用
算法。它是在一个有效的框架中完成这些算法的——你可以将所有的类型划分为少数的几类，然后就可以在模版的参数中使用一种类型替换掉同一种类中的其他类型。
STL提供了大约100个实现算法的模版函数，比如算法for_each将为指定序列中的每一个元素调用指定的函数，stable_sort以你所指定的规则对序列进行稳定性排序等等。这样一来
，只要我们熟悉了STL之后，许多代码可以被大大的化简，只需要通过调用一两个算法模板，就可以完成所需要的功能并大大地提升效率。
 
算法部分主要由头文件<algorithm>，<numeric>和<functional>组成。
<algorithm>是所有STL头文件中最大的一个（尽管它很好理解），它是由一大堆模版函数组成的，可以认为每个函数在很大程度上都是独立的，其中常用到的功能范围涉及到比较、交换、查找、遍历操作、复制、修改、移除、反转、排序、合并等等。
 
<numeric>体积很小，只包括几个在序列上面进行简单数学运算的模板函数，包括加法和乘法在序列上的一些操作。
 
<functional>中则定义了一些模板类，用以声明函数对象。
 
三、容器
在实际的开发过程中，数据结构本身的重要性不会逊于操作于数据结构的算法的重要性，当程序中存在着对时间要求很高的部分时，数据结构的选择就显得更加重要。
经典的数据结构数量有限，但是我们常常重复着一些为了实现向量、链表等结构而编写的代码，这些代码都十分相似，只是为了适应不同数据的变化而在细节上有所出入。STL容器
就为我们提供了这样的方便，它允许我们重复利用已有的实现构造自己的特定类型下的数据结构，通过设置一些模版类，STL容器对最常用的数据结构提供了支持，这些模板的参数
允许我们指定容器中元素的数据类型，可以将我们许多重复而乏味的工作简化。
 
容器部分主要由头文件<vector>,<list>,<deque>,<set>,<map>,<stack>和<queue>组成。对于常用的一些容器和容器适配器（可以看作由其它容器实现的容器），可以通过下表总结一下它们和相应头文件的对应关系。
 
向量(vector) 连续存储的元素<vector>
列表(list)       由节点组成的双向链表，每个结点包含着一个元素<list>
双队列(deque) 连续存储的指向不同元素的指针所组成的数组<deque>
集合(set) 由节点组成的红黑树，每个节点都包含着一个元素，节点之间以某种作用于元素对的谓词排列，没有两个不同的元素能够拥有相同的次序 <set>
多重集合(multiset) 允许存在两个次序相等的元素的集合 <set>
栈(stack) 后进先出的值的排列 <stack>
队列(queue) 先进先出的执的排列 <queue>
优先队列(priority_queue) 元素的次序是由作用于所存储的值对上的某种谓词决定的的一种队列 <queue>
映射(map) 由{键，值}对组成的集合，以某种作用于键对上的谓词排列 <map>
多重映射(multimap) 允许键对有相等的次序的映射 <map>
 
四、迭代器
 
下面要说的迭代器从作用上来说是最基本的部分，可是理解起来比前两者都要费力一些（至少笔者是这样）。软件设计有一个基本原则，所有的问题都可以通过引进一个间接层来
简化，这种简化在STL中就是用迭代器来完成的
。
概括来说，迭代器在STL中用来将算法和容器联系起来，起着一种黏和剂的作用。几乎STL提供的所有算法都是通过迭代器存取元素序列进行工作的，每一个容器都定义了其本身所专有的迭代器，用以存取容器中的元素。
 
迭代器部分主要由头文件<utility>,<iterator>和<memory>组成。
<utility>是一个很小的头文件，它包括了贯穿使用在STL中的几个模板的声明，
<iterator>中提供了迭代器使用的许多方法，而对于<memory>的描述则十分的困难，它以不同寻常的方式为容器中的元素分配存储空间，同时也为某些算法执行期间产生的临时对象提供机制,<memory>中的主要部分是模板类allocator，它负责产生所有容器中的默认分配器。


/* ------------------------------------------------makefile&cmake--------------------------------------------------- */
编译过程（预编译、编译、汇编、链接）：
    1.gcc -E filename.c -o filename.i 
        1.去掉#开头程序，保留#pragma；2.宏替换；3.去注释；4.头文件包含；5.添加行号；
    2.gcc -S filename.i -o filename.s 
        1.语法分析；2.词法分析；3.生成相应的汇编代码
    3.gcc -c filename.s -o filename.o 
        将汇编转成相应的机器语言
    4.gcc filename.o -o filename.exe 
        它通过链接器ld将运行程序的目标文件和库文件链接在一起，生成最后的可执行文件

makefile
    @：不显示命令
    $@：目标文件
    $^：所有依赖文件
    $<：第一个依赖文件
    $?：更新过的文件

    wildcard：扩展通配符
    notdir：去除路径
    patsubst：替换通配符
    basename：获取文件名

例：
    # 头文件、源文件目录
    INC_PATH = ./inc
    SRC_PATH = ./src
    		
    # 搜索目录
    vpath % ./inc
    vpath % ./src

    # 编译环境
    CC = g++ -std=c++11
    AR = ar
    FPIC = -fPIC
    CFLAGS := -Wall -W -O3
    INC_PATH_COMMAND = -I $(INC_PATH)
    
    # OBJECTS
    OBJECTS := $(patsubst %.cpp, %.o, $(notdir $(wildcard $(SRC_PATH)/*.cpp)))
    TARGET = main
    
    $(TARGET) : $(OBJECTS)
    $(CC) $(CFLAGS) -o $@ $^
    
    # 所有的.cpp都生成相应的.o
    %.o : %.cpp
    $(CC) $(CFLAGS) -c $< $(INC_PATH_COMMAND)
    
    .PHONY : clean
    clean : 
    
    -rm -rf *.o

cmake
    cmake_minimun_required(VERSION 3.4.1)：指定CMake的最低版本
    project(xxx)：定义工程名称
    set(FILE_PATH C:\\cpp\\\main.c C:\\cpp\\bspatch.c)：定义变量
    add_executable(<name> ${SRC_LIST})：添加可执行文件
    add_library(bspatch SHARED bspatch.c)：编译为一个名为libbspatch.so的共享库
    
    include_directories(./include ${MY_INCLUDE})：可以用相对货绝对路径，也可以用自定义的变量值
    link_directories("/home/server/third/lib")：添加需要链接的库文件目录
    link_libraries(<name> lib1 lib2 lib3)：将若干库链接到目标库文件
    
    target_include_directories(<name> xxx1 xxx2)
    target_link_libraries(<name> lib1 lib2 lib3)：将若干库链接到目标库文件
    
    add_subdirectory(bzip2)：添加子目录
    add_definitions(-DFOO -DDEBUG ...)：为当前路径以及子目录的源文件加入由-D引入得define flag
    add_compile_options(-std=c++11 -Wall)
    set(EXECUTABLE_OUTPUT_PATH [output_path])：设置可执行文件的输出路径
    set(LIBRARY_OUTPUT_PATH [output_path])：设置库文件的输出路径
    set(CMAKE_VERBOSE_MAKEFILE ON)：设置打印编译代码
    set(CMAKE_BUILD_TYPE "Release") ：设置编译方式
    set(CMAKE_CXX_FLAGS_DEBUG "$ENV{CXXFLAGS} -O0 -Wall -g -ggdb")
    set(CMAKE_CXX_FLAGS_RELEASE "$ENV{CXXFLAGS} -O3 -Wall")
    
    CMAKE_SOURCE_DIR：CMakeLists.txt文件路径
    CMAKE_BINARY_DIR：编译文件路径
    cmake -G"Unix Makefiles" ../：编译cmakelist
    cmake -G"Visual Studio 11 2012" .. 
```