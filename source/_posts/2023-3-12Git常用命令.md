---
uuid: b99c2790-bd77-11ed-ba30-89adbaf27bb4
title: Git常用命令
date: 2023-3-12
tags:
  - Git
categories:
  - Git
abbrlink: caff8000
---

Git常用命令

<!--more-->

## 生成ssh key
ssh-keygen

## 配置
```
git config --global user.name mijm
git config --global user.email jianmingmi@aliyun.com
git config --global core.editor vim（编辑器vim）
git config --global color.ui auto（颜色自动）
git config --global commit.template template.txt
git config --global merge.tool meld
git config --global ssh.variant ssh（git报ssh variant 'simple' does not support setting port）
git config --global http.postBuffer 524288000
git config --global http.sslVerify false（关闭http ssl验证）
git config --global init.defaultBranch master（init默认分支）
git config --global core.autocrlf true（提交时候自动转换crlf为lf）
git config --list
注：--system, /etc/gitconfig; --global, ~/.gitconfig; --local, .git/config
```

## 设置git地址
```
用参数设置git地址：git --git-dir=.repo/manifests/.git --work-tree=.repo/manifests remote -v
设置用户名和密码：git -c user.name=jianmingmi -c user.email=jianming_mi@163.com commit
```

## 远程操作
```
git ls-remote -h [url]（查看远程分支命令）
git remote
    -v（查看远程仓库地址）
    add [remote] [url]（添加远程库）
    remove [remote]（删除hr）
    set-url [remote] [url]（设置新地址）
    get-url --push origin（获取push的url地址）
    rename [old] [new]（重命名）
    update（更新远端分支列表）

git fetch
    git fetch [remote] [branch]（拉test分支到本地）
    git fetch -p （删除远程仓库已经删除的分支）
    git fetch --all（拉所有remote）
    git fetch --depth [n]（深化浅克隆的历史）
    git fetch --unshallow（转换为一个完整的仓库）

    注：git pull = git fetch + git merge
    注：git pull --rebase = git fetch + git rebase

git pull
    git pull [remote] [remote branch]:[local branch or HEAD]
        --rebase（rebase方式合代码）
        --no-tags（不拉tags）
        --depth（克隆深度）

git push
    git push [remote] [local branch or HEAD]:[remote branch]
        -f（强制推送）
        --tags（推送tag）
        --author='mijianming<mijianming@example.com>'
        --no-thin（不做优化，全推）
    git push [remote] :[branch]（删除远端分支）
```


## git init [dir]
```
--bare（初始化git裸仓库（没工作区，镜像）
```

## git clone
```
-b [branch]（分支）
--mirror（镜像仓）
--reference（优先从本地克隆）
--single-branch（拉单一分支）
--depth=1（克隆深度）
--no-tags（不拉tag）
-v（显示详细信息）
-q（不显示信息）
```

## 添加操作
```
git add . -A（添加进缓存区）
git rm [file]（从暂存区移除）
git commit
    -s（Signed-off-by）
    -m（msg）
    --amend（追加提交，会生成新的commit id）
    --no-edit（提交后不编辑）
```

## 分支操作
```
git branch
    [-a] [-v]（查看分支（所有、详细）
    [-d | -D] test（删除分支（-D强制）
git checkout
    master（切换分支（如果没有会创建关联，commit id HEAD游离）
    -b [new branch] [old branch]（切换并创建分支）
```

## 合并操作
```
git merge [branch]
    --edit（合并完后编辑（默认））
    --no-edit（合并完后不编辑）
    --ff（允许快进（默认））
    --no-ff（禁止快进，保留分支，产生节点）
    --squash（创建一个单独的提交而不是做一次合并）
    -s （recursive、resovle、octopus，recursive是默认策略，如遇冲突，直接抛出）
        -s recursive（这是默认的合并策略，这将直接使用递归三路合并算法进行合并）
        -s resovle（让更多的冲突变成手工合并而不是自动合并。这使用的是三路合并算法。普通的三路合并算法会存在发现多个共同祖先的问题。此策略会 “仔细地” 寻找其中一个共同祖先。）
        -s octopus（此策略允许合并多个 git 提交节点（分支）。不过，如果会出现需要手工解决的冲突，那么此策略将不会执行。）
        -s ours（无论有多少个合并分支，当前分支就直接是最终的合并结果，这与策略参数中的ours是不同的，策略参数中会遇到冲突才会用我们的）
        -s subtree（此策略使用的是修改后的递归三路合并算法。与 recursive 不同的是，此策略会将合并的两个分支的其中一个视为另一个的子树，就像 git subtree 中使用的子树一样。）
    -X （ours、theirs、patience、ignore-space-change如果冲突默认使用我们的）
        -X ours（使用我们的）
        -X theirs（使用他们的）
        -X ignore-space-change（空格改动的话就忽略）
        -X find-renames=0（值越小，使文件越相同）
        -X diff-algorithm={patience|minimal|histogram|myers}（指定一个差异算法，myers是默认的，具体算法差异可通过man手册来查看）
            此策略的名称叫 “耐心”，因为 git 将话费更多的时间来进行合并一些看起来不怎么重要的行，合并的结果也更加准确。当然，使用的算法是 recursive 即递归三路合并算法
    注：本分支或者其他分支删除，合并后保留未删除的
    注：二进制合并冲突保留自己的

git rebase [branch]（合并分支，变基方式）
    注：处理完冲突后必须git add .; git rebase --continue（不能使用git commit）
```

## 缓存操作
```
git stash（生成stash，保存未commit的文件，不包括未追踪的）
git stash list（列表）
git stash pop（提取 stash@{n}）
git stash clear（清除）
```

## tag操作
```
git tag [-l 'v1.8.5*']（显示标签）
git tag v1.0 [commit]（轻量标签）
git tag -d v1.0（删除标签）
git checkout v1.0（切换到该提交）
git tag -a v1.0 -m 'release v1.0' [commit]（附注标签）
git show v1.0
git push origin +refs/tags/*:refs/tags/*（推送tag）
git push origin :refs/tags/v1.0（删除tag）
git fetch origin +refs/tags/*:refs/tags/*（拉取tag）
```

## patch操作
```
git diff > xxx.patch
git apply xxx.patch

git format-patch -1 commitid [--binary]
git format-patch commitid..commitid
git am 0001-limit-log-function.patch
```

## log操作
```
git status [-s]（-s，简短输出）
git reflog（查看所有分支log（后悔药））
git show commitid（显示提交信息）
git log [file]
    --no-merges（不查看merge节点）
    --abbrev-commit（显示commit前几个字符）
    --oneline --graph（显示节点信息）
    --stat -p（显示具体修改信息）
    -1（显示第一笔）
    --after, --before（在那些之间）
    --author（仅显示指定作者相关的提交）
    --committer（仅显示指定提交者相关的提交）
    --grep （仅显示含指定关键字的提交）
git log commit1..commit2（查询commit1与commit2之间的记录，不包括commit1，包括commit2）
git log commit1...commit2（查询commit1与commit2之间的记录，包括commit1，包括commit2）
git log --after="2014-7-1" --before="2014-7-4"（按日期查询）
git log --left-right branch1...branch2（查看分支branch1和branch2不同）
git log --color --date=format:'%Y-%m-%d %H:%M:%S' --pretty=format:'%Cred%h%Creset %Cgreen(%cd) %C(yellow)%d%Cblue %s %C(green)(%an)%Creset'
git log --cherry-pick --right-only HEAD...remotes/origin/master --no-merges --oneline（检查没有从master上cherry-pick的提交）

git ll格式化log
    git config --global alias.ll "log --color --date=format:'%Y-%m-%d %H:%M:%S' --pretty=format:'%Cred%h%Creset %Cgreen(%cd) %C(yellow)%d%Cblue %s %C(green)(%an)%Creset'"
```

## diff操作
```
git diff HEAD FETCH_HEAD
git diff（比较工作区和暂存区（add之前和add之后）
git diff HEAD（比较工作区和HEAD（add之前和commit之后，常用）
git diff --cached（比较暂存区和HEAD（add之后和commit之后）
```

## 恢复文件
```
git checkout file（恢复工作区文件和暂存区一致）
    --ours（恢复我们未merge的文件）
    --theirs（恢复他们未merge的文件）
git reset --soft file（回退HEAD）
git reset file（回退HEAD和index）
git reset --hard HEAD（git reset --hard commitid）（HEAD^相当于HEAD~1）（回退HEAD、index和working tree）
git clean -dfx（删除工作区未到暂存区的文件）
git revert [commit]（revert提交）
```

## 其他
```
git cherry-pick [commit]（cherry-pick某笔提交）
    --strategy=recursive -X theirs（如果冲突默认使用别人的代码）
    -m 1 <commitHash>：选择1为父节点，同步2的代码（一般为merge节点，2为基线）

git blame sha1_file.c（查看某些文件修改历史）
    [-L 160,+10]（查看多少行到多少行）
    -e（输出邮箱）

git grep -n xxx（查找哪些地方有包含）

git rebase -i HEAD~2（合并、调整（顺序）最近两次提交，会修改commit id（s合并提交））
git rebase -i commitid（合并、调整（顺序）commitid之前的提交）
```

## 高级用法
```
git fsck --full（检查数据完整性）
git gc --auto（清理优化本地存储）
git symbolic-ref refs/remotes/m/master refs/remotes/origin/master（引用指向引用）
git pack-objects（打包obj，git unpack-objects解压缩）
git pack-refs --all --prune（打包引用）
git rev-parse HEAD（获取HEAD的commit id）
git rev-parse --verify refs/remotes/origin/master（解析分支的commit）
git rev-parse --git-dir（获取git根路径）
git read-tree 6a9756b（读取树对象到暂存区）
git ls-tree -r 93c1491（获取某次提交树对象）
git cat-file -p 93c1491（读取某个对象：提交对象、树对象、数据对象，objects文件中是SHA-1值：文件夹+文件）
git symbolic-ref HEAD refs/for/分支名
git archive --remote=ssh://mijm@gerrit.com:29418/config master note.txt > note.txt
git ls-files -s（显示暂存区内容的对象名称）
git ls-files -u（显示未合并的文件）
git merge-base -a master test（显示两个分支或提交的共同祖先）
    –octopus 计算所有提供的提交的最佳公共祖先，为n路合并做准备
    –independent 不是打印merge base，而是打印具有相同祖先的提交的最小子集。换言之，在给定的提交中，列出无法从任何其他方获得的提交。
    –is-ancester 检查第一个提交是否是第二个提交的祖先，如果是，返回0，如果不是则返回1，结果错误即返回非0非1的状态码；
    –fork-point 找到一个分支从另一个分支分叉的点。这不仅要寻找两个提交的共同祖先，还要考虑到的reflog，以查看导致的历史是否从分支的早期化身派生
    -a --all Output all merge bases for the commits, instead of just one.
```


## git hooks
```
mv .git/hooks/commit-msg.sample .git/hooks/commit-msg
vim .git/hooks/commit-msg
    #!/bin/sh
    #
    # An example hook script to check the commit log message.
    # Called by "git commit" with one argument, the name of the file
    # that has the commit message.  The hook should exit with non-zero
    # status after issuing an appropriate message if it wants to stop the
    # commit.  The hook is allowed to edit the commit message file.
    #
    # To enable this hook, rename this file to "commit-msg".

    branch_name=`git symbolic-ref --short -q HEAD`
    echo "${branch_name}"
    commit="<"${branch_name}">"$(cat $1)
    echo "$commit" > "$1"
```

## 地址替换
```
替换url地址（拉取和推送都会替换）
    [url "ssh://mijm@111.230.209.87:10002"]
        insteadOf = ssh://mijm@111.222.333.444:10002
        insteadOf = ssh://111.222.333.444:10002

仅替换推送url地址
    [url "ssh://mijm@111.230.209.87:10002"]
        pushInsteadOf = ssh://mijm@111.222.333.444:10002
        pushInsteadOf = ssh://111.222.333.444:10002
```

## git-lfs
```
安装
    linux
        sudo apt-get install git-lfs
    windows
        下载：https://github.com/git-lfs/git-lfs/releases/download/v3.3.0/git-lfs-windows-v3.3.0.exe
        一路next
使用
    git push --no-verify（如果一个仓库中包含LFS内容，但是在推送时不想推送这类文件，只要加上 --no-verify选项就行）
    git lfs install（这个命令会自动改变Git配置文件 .gitconfig，而且是全局性质的，取消全局追踪是：git lfs uninstall）
    git lfs track "*.png"（这个命令会更改仓库中的 .gitattributes配置文件，放弃追踪是：git lfs untrack "*.png"）

    git lfs ls-files（查看正在被LFS追踪的文件）
```