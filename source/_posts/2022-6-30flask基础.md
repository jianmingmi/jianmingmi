---
title: flask基础
date: 2022-6-30
tags: [flask]
---

flask基础

<!--more-->

## 文档：
```
w3c教程：https://www.w3cschool.cn/flask/flask_static_files.html
Jinja2语法：https://zhuanlan.zhihu.com/p/462352820

首页：https://dormousehole.readthedocs.io/en/latest/
文档：https://dormousehole.readthedocs.io/en/latest/installation.html
快速上手：https://dormousehole.readthedocs.io/en/latest/quickstart.html
教程：https://dormousehole.readthedocs.io/en/latest/tutorial/index.html
方案：https://dormousehole.readthedocs.io/en/latest/patterns/index.html
API：https://dormousehole.readthedocs.io/en/latest/api.html
部署方式：https://dormousehole.readthedocs.io/en/latest/deploying/index.html
部署：https://dormousehole.readthedocs.io/en/latest/tutorial/deploy.html#
```

## Python 版本
```
我们推荐使用最新版本的 Python 。 Flask 支持 Python 3.6 以上版本。
如果要支持 async ，那么因为会用到 contextvars.ContextVar ，所以需要 Python 3.7 以上版本。
```

## 依赖
```
当安装 Flask 时，以下配套软件会被自动安装。
Werkzeug 用于实现 WSGI ，应用和服务之间的标准 Python 接口。
Jinja 用于渲染页面的模板语言。
MarkupSafe 与 Jinja 共用，在渲染页面时用于避免不可信的输入，防止注入攻击。
ItsDangerous 保证数据完整性的安全标志数据，用于保护 Flask 的 session cookie.
Click 是一个命令行应用的框架。用于提供 flask 命令，并允许添加自定义 管理命令。
```

## 可选依赖
```
以下配套软件不会被自动安装。如果安装了，那么 Flask 会检测到这些软件。
Blinker 为 信号 提供支持。
python-dotenv 当运行 flask 命令时为 通过 dotenv 设置环境变量 提供支持。
Watchdog 为开发服务器提供快速高效的重载。
```

## 虚拟环境
```
建议在开发环境和生产环境下都使用虚拟环境来管理项目的依赖。
为什么要使用虚拟环境？随着你的 Python 项目越来越多，你会发现不同的项目 会需要不同的版本的 Python 库。同一个 Python 库的不同版本可能不兼容。
虚拟环境可以为每一个项目安装独立的 Python 库，这样就可以隔离不同项目之 间的 Python 库，也可以隔离项目与操作系统之间的 Python 库。
Python 内置了用于创建虚拟环境的 venv 模块。
```

## 安装 Flask
```
pip install Flask
```









## 开发说明

### 支持热部署：
```
如果您打开调试模式，那么服务 器会在修改应用代码之后自动重启
```

### 手动转义，防止注入如：`<script>alert("bad")</script>`
```
@app.route("/<name>")
def hello(name):
    return f"Hello, {escape(name)}!"
```

### 接受url参数和类型转换
```
@app.route('/user/<username>')
def show_user_profile(username):
    # show the user profile for that user
    return f'User {escape(username)}'

@app.route('/post/<int:post_id>')
def show_post(post_id):
    # show the post with the given id, the id is an integer
    return f'Post {post_id}'

@app.route('/path/<path:subpath>')
def show_subpath(subpath):
    # show the subpath after /path/
    return f'Subpath {escape(subpath)}'

类型
    string （缺省值） 接受任何不包含斜杠的文本
    int 接受正整数
    float 接受正浮点数
    path 类似 string ，但可以包含斜杠
    uuid 接受 UUID 字符串
```

### url_for作用
```
转义路径
```

### get和post处理
```
from flask import request

@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        return do_the_login()
    else:
        return show_the_login_form()
```

### Jinja2模板引擎
```
from flask import render_template

@app.route('/hello/')
@app.route('/hello/<name>')
def hello(name=None):
    return render_template('hello.html', name=name)

{% ... %} 语法
{{ ... }} 打印输出
{# ... #} 注释
# ... ## for Line Statements

判断
    {% if username == "xxY" %}
        <p>{{ username }}</p>
    {% else %}
        <p>当前的用户名不是xxY</p>
    {% endif %}

遍历
    {% for item in data_ %}
        <tr>
            <td>{{ item[0] }}</td>
            <td>{{ item[1] }}</td>
        </tr>
    {% endfor %}

    {% for key,value in users.items() %}
    {% endfor %}

包含
    {% include 'HTML/samepart/header.html' %}


设置局部变量
    {% with dict={'name': 'Sleet', 'sex': 'male'} %}
        {% for key in dict.keys() %}
            <p>{{ dict[key] }}</p>
        {% endfor %}
    {% endwith %}

    {% with lst = [1,2,3] %}
        {% for i in lst %}
            <p>{{ i }}</p>
        {% endfor %}
    {% endwith %}
```

### 单元测试
```
from flask import request

with app.test_request_context('/hello', method='POST'):
    # now you can do something with the request until the
    # end of the with block, such as basic assertions:
    assert request.path == '/hello'
    assert request.method == 'POST'
```

### 请求对象
```
@app.route('/login', methods=['POST', 'GET'])
def login():
    error = None
    if request.method == 'POST':
        if valid_login(request.form['username'],
                       request.form['password']):
            return log_the_user_in(request.form['username'])
        else:
            error = 'Invalid username/password'
    # the code below is executed if the request method
    # was GET or the credentials were invalid
    return render_template('login.html', error=error)
```

### 文件上传
```
from flask import request

@app.route('/upload', methods=['GET', 'POST'])
def upload_file():
    if request.method == 'POST':
        f = request.files['the_file']
        f.save('/var/www/uploads/uploaded_file.txt')
    ...

from werkzeug.utils import secure_filename

@app.route('/upload', methods=['GET', 'POST'])
def upload_file():
    if request.method == 'POST':
        file = request.files['the_file']
        file.save(f"/var/www/uploads/{secure_filename(file.filename)}")
    ...
```

### cookies
```
from flask import request

@app.route('/')
def index():
    username = request.cookies.get('username')
    # use cookies.get(key) instead of cookies[key] to not get a
    # KeyError if the cookie is missing.
储存 cookies:

from flask import make_response

@app.route('/')
def index():
    resp = make_response(render_template(...))
    resp.set_cookie('username', 'the username')
    return resp
```

### session
```
除了请求对象之外还有一种称为 session 的对象，允许您在不同请求 之间储存信息。这个对象相当于用密钥签名加密的 cookie ，
即用户可以查看您的 cookie ，但是如果没有密钥就无法修改它。

使用会话之前您必须设置一个密钥。举例说明:

from flask import session

# Set the secret key to some random bytes. Keep this really secret!
app.secret_key = b'_5#y2L"F4Q8z\n\xec]/'

@app.route('/')
def index():
    if 'username' in session:
        return f'Logged in as {session["username"]}'
    return 'You are not logged in'

@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        session['username'] = request.form['username']
        return redirect(url_for('index'))
    return '''
        <form method="post">
            <p><input type=text name=username>
            <p><input type=submit value=Login>
        </form>
    '''

@app.route('/logout')
def logout():
    # remove the username from the session if it's there
    session.pop('username', None)
    return redirect(url_for('index'))
```

### 重定向和错误
```
from flask import abort, redirect, url_for

@app.route('/')
def index():
    return redirect(url_for('login'))

@app.route('/login')
def login():
    abort(401)
    this_is_never_executed()
```

### 重定向和错误
```
from flask import abort, redirect, url_for

@app.route('/')
def index():
    return redirect(url_for('login'))

@app.route('/login')
def login():
    abort(401)
    this_is_never_executed()


缺省情况下每种出错代码都会对应显示一个黑白的出错页面。使用 errorhandler() 装饰器可以定制出错页面:
@app.errorhandler(404)
def page_not_found(error):
    return render_template('page_not_found.html'), 404
注意 render_template() 后面的 404 ，这表示页面对就的出错 代码是 404 ，即页面不存在。缺省情况下 200 表示：一切正常。

可以使用 make_response() 包裹返回表达式，获得响应对象，并对该对象 进行修改，然后再返回:
@app.errorhandler(404)
def not_found(error):
    resp = make_response(render_template('error.html'), 404)
    resp.headers['X-Something'] = 'A value'
    return resp
```

### json格式相应
```
JSON 格式的响应是常见的，用 Flask 写这样的 API 是很容易上手的。如果从视图 返回一个 dict ，那么它会被转换为一个 JSON 响应。
    @app.route("/me")
    def me_api():
        user = get_current_user()
        return {
            "username": user.username,
            "theme": user.theme,
            "image": url_for("user_image", filename=user.image),
        }

如果 dict 还不能满足需求，还需要创建其他类型的 JSON 格式响应，可以使用 jsonify() 函数。该函数会序列化任何支持的 JSON 数据类型。 也可以研究研究 Flask 社区扩展，以支持更复杂的应用。
    @app.route("/users")
    def users_api():
        users = get_all_users()
        return jsonify([user.to_json() for user in users])
```

### 消息闪现
```
get_flashed_messages()
```

### 日志处理
```
app.logger.debug('A value for debugging')
app.logger.warning('A warning occurred (%d apples)', 42)
app.logger.error('An error occurred')
```