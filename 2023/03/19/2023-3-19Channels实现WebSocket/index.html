<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="&lt;p&gt;Channels实现WebSocket&lt;/p&gt;"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>Channels实现WebSocket | Mijm Blog</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 6.3.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Archives</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-none-link" href="/tags/Web/" rel="tag">Web</a></div><div class="post-time">2023-03-19</div></div></div><div class="container post-header"><h1>Channels实现WebSocket</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#WebSocket%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">WebSocket是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WebSocket%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">WebSocket有什么用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Channels"><span class="toc-number">3.</span> <span class="toc-text">Channels</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E6%88%90Channels"><span class="toc-number">4.</span> <span class="toc-text">集成Channels</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E8%81%8A%E5%A4%A9%E5%AE%A4"><span class="toc-number">5.</span> <span class="toc-text">构建聊天室</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AF%E7%94%A8Channel-Layer"><span class="toc-number">6.</span> <span class="toc-text">启用Channel Layer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E4%B8%BA%E5%BC%82%E6%AD%A5"><span class="toc-number">7.</span> <span class="toc-text">修改为异步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E6%96%87"><span class="toc-number">8.</span> <span class="toc-text">原文</span></a></li></ol></details></div><div class="container post-content"><p>Channels实现WebSocket</p>
<span id="more"></span>

<h2 id="WebSocket是什么？"><a href="#WebSocket是什么？" class="headerlink" title="WebSocket是什么？"></a>WebSocket是什么？</h2><p>WebSocket是一种在单个TCP连接上进行全双工通讯的协议。WebSocket允许服务端主动向客户端推送数据。在WebSocket协议中，客户端浏览器和服务器只需要完成一次握手就可以创建持久性的连接，并在浏览器和服务器之间进行双向的数据传输。</p>
<h2 id="WebSocket有什么用？"><a href="#WebSocket有什么用？" class="headerlink" title="WebSocket有什么用？"></a>WebSocket有什么用？</h2><p>WebSocket区别于HTTP协议的一个最为显著的特点是，WebSocket协议可以由服务端主动发起消息，对于浏览器需要及时接收数据变化的场景非常适合，例如在Django中遇到一些耗时较长的任务我们通常会使用Celery来异步执行，那么浏览器如果想要获取这个任务的执行状态，在HTTP协议中只能通过轮训的方式由浏览器不断的发送请求给服务器来获取最新状态，这样发送很多无用的请求不仅浪费资源，还不够优雅，如果使用WebSokcet来实现就很完美了</p>
<p>WebSocket的另外一个应用场景就是下文要说的聊天室，一个用户（浏览器）发送的消息需要实时的让其他用户（浏览器）接收，这在HTTP协议下是很难实现的，但WebSocket基于长连接加上可以主动给浏览器发消息的特性处理起来就游刃有余了</p>
<p>初步了解WebSocket之后，我们看看如何在Django中实现WebSocket</p>
<h2 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a>Channels</h2><p>Django本身不支持WebSocket，但可以通过集成Channels框架来实现WebSocket</p>
<p>Channels是针对Django项目的一个增强框架，可以使Django不仅支持HTTP协议，还能支持WebSocket，MQTT等多种协议，同时Channels还整合了Django的auth以及session系统方便进行用户管理及认证。</p>
<p>我下文所有的代码实现使用以下python和Django版本</p>
<ul>
<li>python&#x3D;&#x3D;3.6.3</li>
<li>django&#x3D;&#x3D;2.2</li>
</ul>
<h2 id="集成Channels"><a href="#集成Channels" class="headerlink" title="集成Channels"></a>集成Channels</h2><p>我假设你已经新建了一个django项目，<code>项目名字就叫webapp</code>，目录结构如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">project</span><br><span class="line">    - webapp</span><br><span class="line">        - __init__.py</span><br><span class="line">        - settings.py</span><br><span class="line">        - urls.py</span><br><span class="line">        - wsgi.py</span><br><span class="line">    - manage.py</span><br></pre></td></tr></table></figure>

<ol>
<li>安装channels</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install channels==2.1.7</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改settings.py文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># APPS中添加channels</span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">    &#x27;django.contrib.staticfiles&#x27;,</span><br><span class="line">    &#x27;channels&#x27;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"># 指定ASGI的路由地址</span><br><span class="line">ASGI_APPLICATION = &#x27;webapp.routing.application&#x27;</span><br></pre></td></tr></table></figure>

<p>channels运行于ASGI协议上，ASGI的全名是Asynchronous Server Gateway Interface。它是区别于Django使用的WSGI协议 的一种异步服务网关接口协议，正是因为它才实现了websocket</p>
<p><code>ASGI_APPLICATION</code> 指定主路由的位置为webapp下的routing.py文件中的application</p>
<ol start="3">
<li>setting.py的同级目录下创建routing.py路由文件，routing.py类似于Django中的url.py指明websocket协议的路由</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from channels.routing import ProtocolTypeRouter</span><br><span class="line"></span><br><span class="line">application = ProtocolTypeRouter(&#123;</span><br><span class="line">    # 暂时为空，下文填充</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>运行Django项目</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">C:\python36\python.exe D:/demo/tailf/manage.py runserver 0.0.0.0:80</span><br><span class="line">Performing system checks...</span><br><span class="line">Watching for file changes with StatReloader</span><br><span class="line"></span><br><span class="line">System check identified no issues (0 silenced).</span><br><span class="line">April 12, 2019 - 17:44:52</span><br><span class="line">Django version 2.2, using settings &#x27;webapp.settings&#x27;</span><br><span class="line">Starting ASGI/Channels version 2.1.7 development server at http://0.0.0.0:80/</span><br><span class="line">Quit the server with CTRL-BREAK.</span><br></pre></td></tr></table></figure>

<p>仔细观察上边的输出会发现Django启动中的<code>Starting development server</code>已经变成了<code>Starting ASGI/Channels version 2.1.7 development server</code>，这表明项目已经由django使用的WSGI协议转换为了Channels使用的ASGI协议</p>
<p>至此Django已经基本集成了Channels框架</p>
<h2 id="构建聊天室"><a href="#构建聊天室" class="headerlink" title="构建聊天室"></a>构建聊天室</h2><p>上边虽然在项目中集成了Channels，但并没有任何的应用使用它，接下来我们以聊天室的例子来讲解Channels的使用</p>
<p>假设你已经创建好了一个叫chat的app，并添加到了settings.py的INSTALLED_APPS中，app的目录结构大概如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">chat</span><br><span class="line">    - migrations</span><br><span class="line">        - __init__.py</span><br><span class="line">    - __init__.py</span><br><span class="line">    - admin.py</span><br><span class="line">    - apps.py</span><br><span class="line">    - models.py</span><br><span class="line">    - tests.py</span><br><span class="line">    - views.py</span><br></pre></td></tr></table></figure>

<p>我们构建一个标准的Django聊天页面，相关代码如下</p>
<p>url:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from django.urls import path</span><br><span class="line">from chat.views import chat</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(&#x27;chat&#x27;, chat, name=&#x27;chat-url&#x27;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>view:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from django.shortcuts import render</span><br><span class="line"></span><br><span class="line">def chat(request):</span><br><span class="line">    return render(request, &#x27;chat/index.html&#x27;)</span><br></pre></td></tr></table></figure>

<p>template:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends &quot;base.html&quot; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">  &lt;textarea class=&quot;form-control&quot; id=&quot;chat-log&quot; disabled rows=&quot;20&quot;&gt;&lt;/textarea&gt;&lt;br/&gt;</span><br><span class="line">  &lt;input class=&quot;form-control&quot; id=&quot;chat-message-input&quot; type=&quot;text&quot;/&gt;&lt;br/&gt;</span><br><span class="line">  &lt;input class=&quot;btn btn-success btn-block&quot; id=&quot;chat-message-submit&quot; type=&quot;button&quot; value=&quot;Send&quot;/&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>

<p>通过上边的代码一个简单的web聊天页面构建完成了，访问页面大概样子如下：</p>
<p><img src="/images/2023-3-19Channels%E5%AE%9E%E7%8E%B0WebSocket/1.jpg"></p>
<p>接下来我们利用Channels的WebSocket协议实现消息的发送接收功能</p>
<ol>
<li>先从路由入手，上边我们已经创建了routing.py路由文件，现在来填充里边的内容</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from channels.auth import AuthMiddlewareStack</span><br><span class="line">from channels.routing import ProtocolTypeRouter, URLRouter</span><br><span class="line">import chat.routing</span><br><span class="line"></span><br><span class="line">application = ProtocolTypeRouter(&#123;</span><br><span class="line">    &#x27;websocket&#x27;: AuthMiddlewareStack(</span><br><span class="line">        URLRouter(</span><br><span class="line">            chat.routing.websocket_urlpatterns</span><br><span class="line">        )</span><br><span class="line">    ),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>ProtocolTypeRouter</code>： ASIG支持多种不同的协议，在这里可以指定特定协议的路由信息，我们只使用了websocket协议，这里只配置websocket即可</p>
<p><code>AuthMiddlewareStack</code>： django的channels封装了django的auth模块，使用这个配置我们就可以在consumer中通过下边的代码获取到用户的信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def connect(self):</span><br><span class="line">    self.user = self.scope[&quot;user&quot;]</span><br></pre></td></tr></table></figure>

<p><code>self.scope</code>类似于django中的request，包含了请求的type、path、header、cookie、session、user等等有用的信息</p>
<p>URLRouter： 指定路由文件的路径，也可以直接将路由信息写在这里，代码中配置了路由文件的路径，会去chat下的routeing.py文件中查找websocket_urlpatterns，<code>chat/routing.py</code>内容如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from django.urls import path</span><br><span class="line">from chat.consumers import ChatConsumer</span><br><span class="line"></span><br><span class="line">websocket_urlpatterns = [</span><br><span class="line">    path(&#x27;ws/chat/&#x27;, ChatConsumer),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>routing.py路由文件跟django的url.py功能类似，语法也一样，意思就是访问<code>ws/chat/</code>都交给<code>ChatConsumer</code>处理</p>
<ol start="2">
<li>接着编写consumer，consumer类似django中的view，内容如下</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from channels.generic.websocket import WebsocketConsumer</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">class ChatConsumer(WebsocketConsumer):</span><br><span class="line">    def connect(self):</span><br><span class="line">        self.accept()</span><br><span class="line"></span><br><span class="line">    def disconnect(self, close_code):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def receive(self, text_data):</span><br><span class="line">        text_data_json = json.loads(text_data)</span><br><span class="line">        message = &#x27;运维：&#x27; + text_data_json[&#x27;message&#x27;]</span><br><span class="line"></span><br><span class="line">        self.send(text_data=json.dumps(&#123;</span><br><span class="line">            &#x27;message&#x27;: message</span><br><span class="line">        &#125;))</span><br></pre></td></tr></table></figure>

<p>这里是个最简单的同步websocket consumer类，connect方法在连接建立时触发，disconnect在连接关闭时触发，receive方法会在收到消息后触发。整个ChatConsumer类会将所有收到的消息加上“运维：”的前缀发送给客户端</p>
<ol start="3">
<li>最后我们在html模板页面添加websocket支持</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends &quot;base.html&quot; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">  &lt;textarea class=&quot;form-control&quot; id=&quot;chat-log&quot; disabled rows=&quot;20&quot;&gt;&lt;/textarea&gt;&lt;br/&gt;</span><br><span class="line">  &lt;input class=&quot;form-control&quot; id=&quot;chat-message-input&quot; type=&quot;text&quot;/&gt;&lt;br/&gt;</span><br><span class="line">  &lt;input class=&quot;btn btn-success btn-block&quot; id=&quot;chat-message-submit&quot; type=&quot;button&quot; value=&quot;Send&quot;/&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block js %&#125;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  var chatSocket = new WebSocket(</span><br><span class="line">    &#x27;ws://&#x27; + window.location.host + &#x27;/ws/chat/&#x27;);</span><br><span class="line"></span><br><span class="line">  chatSocket.onmessage = function(e) &#123;</span><br><span class="line">    var data = JSON.parse(e.data);</span><br><span class="line">    var message = data[&#x27;message&#x27;];</span><br><span class="line">    document.querySelector(&#x27;#chat-log&#x27;).value += (message + &#x27;\n&#x27;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  chatSocket.onclose = function(e) &#123;</span><br><span class="line">    console.error(&#x27;Chat socket closed unexpectedly&#x27;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  document.querySelector(&#x27;#chat-message-input&#x27;).focus();</span><br><span class="line">  document.querySelector(&#x27;#chat-message-input&#x27;).onkeyup = function(e) &#123;</span><br><span class="line">    if (e.keyCode === 13) &#123;  // enter, return</span><br><span class="line">        document.querySelector(&#x27;#chat-message-submit&#x27;).click();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  document.querySelector(&#x27;#chat-message-submit&#x27;).onclick = function(e) &#123;</span><br><span class="line">    var messageInputDom = document.querySelector(&#x27;#chat-message-input&#x27;);</span><br><span class="line">    var message = messageInputDom.value;</span><br><span class="line">    chatSocket.send(JSON.stringify(&#123;</span><br><span class="line">        &#x27;message&#x27;: message</span><br><span class="line">    &#125;));</span><br><span class="line"></span><br><span class="line">    messageInputDom.value = &#x27;&#x27;;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>

<p>WebSocket对象一个支持四个消息：onopen，onmessage，oncluse和onerror，我们这里用了两个onmessage和onclose</p>
<p>onopen： 当浏览器和websocket服务端连接成功后会触发onopen消息</p>
<p>onerror： 如果连接失败，或者发送、接收数据失败，或者数据处理出错都会触发onerror消息</p>
<p>onmessage： 当浏览器接收到websocket服务器发送过来的数据时，就会触发onmessage消息，参数<code>e</code>包含了服务端发送过来的数据</p>
<p>onclose： 当浏览器接收到websocket服务器发送过来的关闭连接请求时，会触发onclose消息</p>
<ol start="4">
<li>完成前边的代码，一个可以聊天的websocket页面就完成了，运行项目，在浏览器中输入消息就会通过websocket–&gt;rouging.py–&gt;consumer.py处理后返回给前端</li>
</ol>
<p><img src="/images/2023-3-19Channels%E5%AE%9E%E7%8E%B0WebSocket/2.jpg"></p>
<h2 id="启用Channel-Layer"><a href="#启用Channel-Layer" class="headerlink" title="启用Channel Layer"></a>启用Channel Layer</h2><p>上边的例子我们已经实现了消息的发送和接收，但既然是聊天室，肯定要支持多人同时聊天的，当我们打开多个浏览器分别输入消息后发现只有自己收到消息，其他浏览器端收不到，如何解决这个问题，让所有客户端都能一起聊天呢？</p>
<p>Channels引入了一个layer的概念，channel layer是一种通信系统，允许多个consumer实例之间互相通信，以及与外部Djanbo程序实现互通。</p>
<p>channel layer主要实现了两种概念抽象：</p>
<p>channel name： channel实际上就是一个发送消息的通道，每个Channel都有一个名称，每一个拥有这个名称的人都可以往Channel里边发送消息</p>
<p>group： 多个channel可以组成一个Group，每个Group都有一个名称，每一个拥有这个名称的人都可以往Group里添加&#x2F;删除Channel，也可以往Group里发送消息，Group内的所有channel都可以收到，但是无法发送给Group内的具体某个Channel</p>
<p>了解了上边的概念，接下来我们利用channel layer实现真正的聊天室，能够让多个客户端发送的消息被彼此看到</p>
<ol>
<li><p>官方推荐使用redis作为channel layer，所以先安装channels_redis</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install channels_redis==2.3.3</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后修改settings.py添加对layer的支持</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CHANNEL_LAYERS = &#123;</span><br><span class="line">    &#x27;default&#x27;: &#123;</span><br><span class="line">        &#x27;BACKEND&#x27;: &#x27;channels_redis.core.RedisChannelLayer&#x27;,</span><br><span class="line">        &#x27;CONFIG&#x27;: &#123;</span><br><span class="line">            &quot;hosts&quot;: [(&#x27;ops-coffee.cn&#x27;, 6379)],</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加channel之后我们可以通过以下命令检查通道层是否能够正常工作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;python manage.py shell</span><br><span class="line">Python 3.6.3 (v3.6.3:2c5fed8, Oct  3 2017, 18:11:49) [MSC v.1900 64 bit (AMD64)] on win32</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">(InteractiveConsole)</span><br><span class="line">&gt;&gt;&gt; import channels.layers</span><br><span class="line">&gt;&gt;&gt; channel_layer = channels.layers.get_channel_layer()</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; from asgiref.sync import async_to_sync</span><br><span class="line">&gt;&gt;&gt; async_to_sync(channel_layer.send)(&#x27;test_channel&#x27;,&#123;&#x27;site&#x27;:&#x27;https://ops-coffee.cn&#x27;&#125;)</span><br><span class="line">&gt;&gt;&gt; async_to_sync(channel_layer.receive)(&#x27;test_channel&#x27;)</span><br><span class="line">&#123;&#x27;site&#x27;: &#x27;https://ops-coffee.cn&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>consumer做如下修改引入channel layer</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">from asgiref.sync import async_to_sync</span><br><span class="line">from channels.generic.websocket import WebsocketConsumer</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">class ChatConsumer(WebsocketConsumer):</span><br><span class="line">    def connect(self):</span><br><span class="line">        self.room_group_name = &#x27;ops_coffee&#x27;</span><br><span class="line"></span><br><span class="line">        # Join room group</span><br><span class="line">        async_to_sync(self.channel_layer.group_add)(</span><br><span class="line">            self.room_group_name,</span><br><span class="line">            self.channel_name</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        self.accept()</span><br><span class="line"></span><br><span class="line">    def disconnect(self, close_code):</span><br><span class="line">        # Leave room group</span><br><span class="line">        async_to_sync(self.channel_layer.group_discard)(</span><br><span class="line">            self.room_group_name,</span><br><span class="line">            self.channel_name</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    # Receive message from WebSocket</span><br><span class="line">    def receive(self, text_data):</span><br><span class="line">        text_data_json = json.loads(text_data)</span><br><span class="line">        message = text_data_json[&#x27;message&#x27;]</span><br><span class="line"></span><br><span class="line">        # Send message to room group</span><br><span class="line">        async_to_sync(self.channel_layer.group_send)(</span><br><span class="line">            self.room_group_name,</span><br><span class="line">            &#123;</span><br><span class="line">                &#x27;type&#x27;: &#x27;chat_message&#x27;,</span><br><span class="line">                &#x27;message&#x27;: message</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    # Receive message from room group</span><br><span class="line">    def chat_message(self, event):</span><br><span class="line">        message = &#x27;运维：&#x27; + event[&#x27;message&#x27;]</span><br><span class="line"></span><br><span class="line">        # Send message to WebSocket</span><br><span class="line">        self.send(text_data=json.dumps(&#123;</span><br><span class="line">            &#x27;message&#x27;: message</span><br><span class="line">        &#125;))</span><br></pre></td></tr></table></figure>

<p>这里我们设置了一个固定的房间名作为Group name，所有的消息都会发送到这个Group里边，当然你也可以通过参数的方式将房间名传进来作为Group name，从而建立多个Group，这样可以实现仅同房间内的消息互通</p>
<p>当我们启用了channel layer之后，所有与consumer之间的通信将会变成异步的，所以必须使用<code>async_to_sync</code></p>
<p>一个链接（channel）创建时，通过<code>group_add</code>将channel添加到Group中，链接关闭通过<code>group_discard</code>将channel从Group中剔除，收到消息时可以调用<code>group_send</code>方法将消息发送到Group，这个Group内所有的channel都可以收的到</p>
<p><code>group_send</code>中的type指定了消息处理的函数，这里会将消息转给<code>chat_message</code>函数去处理</p>
<ol start="4">
<li>经过以上的修改，我们再次在多个浏览器上打开聊天页面输入消息，发现彼此已经能够看到了，至此一个完整的聊天室已经基本完成</li>
</ol>
<h2 id="修改为异步"><a href="#修改为异步" class="headerlink" title="修改为异步"></a>修改为异步</h2><p>我们前边实现的consumer是同步的，为了能有更好的性能，官方支持异步的写法，只需要修改consumer.py即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">from channels.generic.websocket import AsyncWebsocketConsumer</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">class ChatConsumer(AsyncWebsocketConsumer):</span><br><span class="line">    async def connect(self):</span><br><span class="line">        self.room_group_name = &#x27;ops_coffee&#x27;</span><br><span class="line"></span><br><span class="line">        # Join room group</span><br><span class="line">        await self.channel_layer.group_add(</span><br><span class="line">            self.room_group_name,</span><br><span class="line">            self.channel_name</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        await self.accept()</span><br><span class="line"></span><br><span class="line">    async def disconnect(self, close_code):</span><br><span class="line">        # Leave room group</span><br><span class="line">        await self.channel_layer.group_discard(</span><br><span class="line">            self.room_group_name,</span><br><span class="line">            self.channel_name</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    # Receive message from WebSocket</span><br><span class="line">    async def receive(self, text_data):</span><br><span class="line">        text_data_json = json.loads(text_data)</span><br><span class="line">        message = text_data_json[&#x27;message&#x27;]</span><br><span class="line"></span><br><span class="line">        # Send message to room group</span><br><span class="line">        await self.channel_layer.group_send(</span><br><span class="line">            self.room_group_name,</span><br><span class="line">            &#123;</span><br><span class="line">                &#x27;type&#x27;: &#x27;chat_message&#x27;,</span><br><span class="line">                &#x27;message&#x27;: message</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    # Receive message from room group</span><br><span class="line">    async def chat_message(self, event):</span><br><span class="line">        message = &#x27;运维：&#x27; + event[&#x27;message&#x27;]</span><br><span class="line"></span><br><span class="line">        # Send message to WebSocket</span><br><span class="line">        await self.send(text_data=json.dumps(&#123;</span><br><span class="line">            &#x27;message&#x27;: message</span><br><span class="line">        &#125;))</span><br></pre></td></tr></table></figure>

<p>其实异步的代码跟之前的差别不大，只有几个小区别：</p>
<p>ChatConsumer由<code>WebsocketConsumer</code>修改为了<code>AsyncWebsocketConsumer</code></p>
<p>所有的方法都修改为了异步<code>defasync def</code></p>
<p>用<code>await</code>来实现异步I&#x2F;O的调用</p>
<p>channel layer也不再需要使用<code>async_to_sync</code>了</p>
<h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/hqaPrPS7w3D-9SeegQAB2Q">地址</a></p>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/lato-font/3.0.0/css/lato-font.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcdn.net/ajax/libs/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcdn.net/ajax/libs/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>